[
  {
    "_comment": "=== CHAOS / DESTRUCTION SYSTEM === (API: Runtime/Chaos, Runtime/GeometryCollectionEngine, Plugins/ChaosCaching, Editor/GeometryCollectionEditor)",
    "name": "chaos.create_geometry_collection",
    "description": "Create a new Geometry Collection asset from selected static meshes for Chaos destruction. Uses UGeometryCollectionFactory.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source_meshes": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Array of static mesh asset paths to include (e.g. /Game/Meshes/Wall)."
        },
        "asset_path": {
          "type": "string",
          "description": "Content path for the new Geometry Collection asset."
        },
        "asset_name": {
          "type": "string",
          "description": "Name for the new Geometry Collection asset."
        }
      },
      "additionalProperties": false,
      "required": ["source_meshes", "asset_path", "asset_name"]
    }
  },
  {
    "name": "chaos.fracture_mesh",
    "description": "Apply fracture to a Geometry Collection using Voronoi, Planar, Cluster, or Radial methods. Uses FGeometryCollectionCommandCommon.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "geometry_collection": {
          "type": "string",
          "description": "Asset path to the Geometry Collection."
        },
        "method": {
          "type": "string",
          "enum": ["voronoi", "planar", "cluster", "radial", "brick", "mesh_cut"],
          "description": "Fracture algorithm to use."
        },
        "num_pieces": {
          "type": "integer",
          "description": "Target number of fracture pieces.",
          "default": 10
        },
        "random_seed": {
          "type": "integer",
          "description": "Random seed for deterministic fractures.",
          "default": -1
        },
        "grout_amount": {
          "type": "number",
          "description": "Gap between fractured pieces (0.0 = no gap).",
          "default": 0.0
        },
        "noise_amount": {
          "type": "number",
          "description": "Amount of noise to apply to fracture surfaces (0.0 - 1.0).",
          "default": 0.0
        },
        "bone_selection": {
          "type": "array",
          "items": { "type": "integer" },
          "description": "Bone indices to fracture. Empty = fracture all."
        }
      },
      "additionalProperties": false,
      "required": ["geometry_collection", "method"]
    }
  },
  {
    "name": "chaos.set_damage_threshold",
    "description": "Set damage thresholds on Geometry Collection bones to control when pieces break off.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "geometry_collection": {
          "type": "string",
          "description": "Asset path to the Geometry Collection."
        },
        "bone_indices": {
          "type": "array",
          "items": { "type": "integer" },
          "description": "Bone indices to set threshold on. Empty = apply to all."
        },
        "damage_threshold": {
          "type": "number",
          "description": "Damage threshold value. Higher = harder to break."
        },
        "enable_damage": {
          "type": "boolean",
          "description": "Whether damage is enabled on these bones.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["geometry_collection", "damage_threshold"]
    }
  },
  {
    "name": "chaos.set_clustering",
    "description": "Configure cluster hierarchy on a Geometry Collection for multi-level destruction.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "geometry_collection": {
          "type": "string",
          "description": "Asset path to the Geometry Collection."
        },
        "cluster_levels": {
          "type": "integer",
          "description": "Number of cluster hierarchy levels.",
          "default": 1
        },
        "cluster_connection_type": {
          "type": "string",
          "enum": ["pointImplicit", "delaunay", "minimalSpanningSubsetDelaunay", "pointImplicitAugmentedWithMinimalDelaunay"],
          "description": "Method for computing cluster connections."
        },
        "max_cluster_size": {
          "type": "integer",
          "description": "Maximum number of children per cluster node."
        }
      },
      "additionalProperties": false,
      "required": ["geometry_collection"]
    }
  },
  {
    "name": "chaos.add_field_system",
    "description": "Add a Chaos Field System actor to the level (external strain, sleep, kill, disable fields). Uses AFieldSystemActor.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "field_type": {
          "type": "string",
          "enum": ["external_strain", "sleep", "kill", "disable", "linear_force", "noise"],
          "description": "Type of field to add."
        },
        "location": {
          "type": "object",
          "properties": {
            "x": { "type": "number" },
            "y": { "type": "number" },
            "z": { "type": "number" }
          },
          "required": ["x", "y", "z"],
          "description": "World location for the field actor."
        },
        "magnitude": {
          "type": "number",
          "description": "Field strength/magnitude value.",
          "default": 1000.0
        },
        "radius": {
          "type": "number",
          "description": "Radius of effect for radial fields.",
          "default": 500.0
        },
        "falloff_type": {
          "type": "string",
          "enum": ["none", "linear", "inverse", "squared"],
          "description": "Falloff curve type.",
          "default": "linear"
        }
      },
      "additionalProperties": false,
      "required": ["field_type", "location"]
    }
  },
  {
    "name": "chaos.set_anchor",
    "description": "Set anchor fields on Geometry Collection bones to keep specific pieces static until the anchor is broken.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": {
          "type": "string",
          "description": "Name or label of the GeometryCollectionActor in the level."
        },
        "bone_indices": {
          "type": "array",
          "items": { "type": "integer" },
          "description": "Bone indices to anchor."
        },
        "anchor_type": {
          "type": "string",
          "enum": ["static", "kinematic"],
          "description": "Type of anchor to apply."
        }
      },
      "additionalProperties": false,
      "required": ["actor", "bone_indices"]
    }
  },
  {
    "name": "chaos.enable_caching",
    "description": "Enable/configure Chaos caching for deterministic destruction replay. Uses UChaosCacheCollection.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": {
          "type": "string",
          "description": "GeometryCollectionActor name/label."
        },
        "enable": {
          "type": "boolean",
          "description": "Enable or disable caching.",
          "default": true
        },
        "cache_mode": {
          "type": "string",
          "enum": ["record", "play", "none"],
          "description": "Caching mode to set."
        }
      },
      "additionalProperties": false,
      "required": ["actor"]
    }
  },
  {
    "name": "chaos.validate",
    "description": "Validate a Geometry Collection asset for issues (missing data, invalid hierarchy, unreferenced bones).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "geometry_collection": {
          "type": "string",
          "description": "Asset path to the Geometry Collection."
        }
      },
      "additionalProperties": false,
      "required": ["geometry_collection"]
    }
  },

  {
    "_comment": "=== CLOTH SIMULATION SYSTEM === (API: Plugins/ChaosClothAsset, Editor/ClothingSystemEditor, Editor/ClothPainter, Runtime/ClothingSystemRuntimeCommon)",
    "name": "cloth.create_asset",
    "description": "Create a new Chaos Cloth asset from a skeletal mesh. Uses UChaosClothAssetFactory.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skeletal_mesh": {
          "type": "string",
          "description": "Asset path to the source skeletal mesh."
        },
        "lod_index": {
          "type": "integer",
          "description": "LOD level to extract cloth mesh from.",
          "default": 0
        },
        "section_index": {
          "type": "integer",
          "description": "Mesh section index for the cloth region."
        },
        "asset_name": {
          "type": "string",
          "description": "Name for the new cloth asset."
        },
        "asset_path": {
          "type": "string",
          "description": "Content folder path for the asset."
        }
      },
      "additionalProperties": false,
      "required": ["skeletal_mesh", "section_index", "asset_name", "asset_path"]
    }
  },
  {
    "name": "cloth.paint_weights",
    "description": "Paint cloth simulation weights on a skeletal mesh (max distance, backstop, etc.). Uses FClothPainter.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skeletal_mesh": {
          "type": "string",
          "description": "Asset path to the skeletal mesh with cloth data."
        },
        "cloth_index": {
          "type": "integer",
          "description": "Index of the cloth asset on the mesh.",
          "default": 0
        },
        "weight_type": {
          "type": "string",
          "enum": ["max_distance", "backstop_distance", "backstop_radius", "anim_drive_stiffness", "anim_drive_damping"],
          "description": "Which weight channel to paint."
        },
        "paint_value": {
          "type": "number",
          "description": "Value to paint (0.0 - max, depends on weight type)."
        },
        "vertex_indices": {
          "type": "array",
          "items": { "type": "integer" },
          "description": "Specific vertex indices to paint. Empty = paint all."
        }
      },
      "additionalProperties": false,
      "required": ["skeletal_mesh", "weight_type", "paint_value"]
    }
  },
  {
    "name": "cloth.set_simulation_config",
    "description": "Configure cloth simulation parameters (stiffness, damping, gravity, collision). Uses FClothConfigCommon.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skeletal_mesh": {
          "type": "string",
          "description": "Asset path to the skeletal mesh."
        },
        "cloth_index": {
          "type": "integer",
          "description": "Index of the cloth asset.",
          "default": 0
        },
        "mass_mode": {
          "type": "string",
          "enum": ["uniform_mass", "total_mass", "density"],
          "description": "How mass is distributed."
        },
        "mass_value": {
          "type": "number",
          "description": "Mass value (interpretation depends on mass_mode)."
        },
        "stiffness": {
          "type": "number",
          "description": "Edge stiffness (0.0 - 1.0)."
        },
        "bending_stiffness": {
          "type": "number",
          "description": "Bending stiffness (0.0 - 1.0)."
        },
        "damping": {
          "type": "number",
          "description": "Velocity damping coefficient."
        },
        "gravity_scale": {
          "type": "number",
          "description": "Gravity multiplier for this cloth.",
          "default": 1.0
        },
        "friction": {
          "type": "number",
          "description": "Friction coefficient for cloth-body collision."
        },
        "collision_thickness": {
          "type": "number",
          "description": "Thickness offset for collision detection."
        },
        "self_collision": {
          "type": "boolean",
          "description": "Enable self-collision detection.",
          "default": false
        },
        "wind_method": {
          "type": "string",
          "enum": ["legacy", "accurate"],
          "description": "Wind simulation method."
        }
      },
      "additionalProperties": false,
      "required": ["skeletal_mesh"]
    }
  },
  {
    "name": "cloth.set_collision_data",
    "description": "Configure cloth collision bodies (capsules, spheres, convex) extracted from physics asset.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skeletal_mesh": {
          "type": "string",
          "description": "Asset path to the skeletal mesh."
        },
        "cloth_index": {
          "type": "integer",
          "default": 0
        },
        "extract_from_physics_asset": {
          "type": "boolean",
          "description": "Extract collision shapes from the bound physics asset.",
          "default": true
        },
        "bone_filter": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Only include collision for these bone names."
        }
      },
      "additionalProperties": false,
      "required": ["skeletal_mesh"]
    }
  },
  {
    "name": "cloth.validate",
    "description": "Validate cloth setup on a skeletal mesh for common issues.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skeletal_mesh": {
          "type": "string",
          "description": "Asset path to validate."
        }
      },
      "additionalProperties": false,
      "required": ["skeletal_mesh"]
    }
  },

  {
    "_comment": "=== WATER SYSTEM === (API: Plugins/Water, Plugins/WaterEditor)",
    "name": "water.create_body",
    "description": "Spawn a Water Body actor in the level (ocean, lake, river, or custom). Uses AWaterBody.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "water_type": {
          "type": "string",
          "enum": ["ocean", "lake", "river", "custom"],
          "description": "Type of water body to create."
        },
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "required": ["x", "y", "z"]
        },
        "label": {
          "type": "string",
          "description": "Actor label."
        },
        "spline_points": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
          },
          "description": "Spline points defining the water body shape (for river/lake)."
        }
      },
      "additionalProperties": false,
      "required": ["water_type", "location"]
    }
  },
  {
    "name": "water.set_wave_params",
    "description": "Configure wave simulation parameters on a water body (Gerstner waves). Uses FWaterWaves.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": {
          "type": "string",
          "description": "Water body actor name/label."
        },
        "wave_amplitude": {
          "type": "number",
          "description": "Maximum wave height."
        },
        "wave_length": {
          "type": "number",
          "description": "Distance between wave peaks."
        },
        "wave_speed": {
          "type": "number",
          "description": "Speed of wave movement."
        },
        "wind_direction": {
          "type": "number",
          "description": "Wind direction angle in degrees (0-360)."
        },
        "steepness": {
          "type": "number",
          "description": "Wave steepness (Gerstner parameter, 0.0-1.0)."
        },
        "num_waves": {
          "type": "integer",
          "description": "Number of overlapping Gerstner waves.",
          "default": 4
        }
      },
      "additionalProperties": false,
      "required": ["actor"]
    }
  },
  {
    "name": "water.set_material",
    "description": "Set material or material parameters on a water body.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": {
          "type": "string",
          "description": "Water body actor name/label."
        },
        "material": {
          "type": "string",
          "description": "Material asset path to assign."
        },
        "underwater_material": {
          "type": "string",
          "description": "Material for underwater post-process effect."
        },
        "shallow_color": {
          "type": "object",
          "properties": { "r": { "type": "number" }, "g": { "type": "number" }, "b": { "type": "number" }, "a": { "type": "number" } },
          "description": "Shallow water tint color (RGBA 0-1)."
        },
        "deep_color": {
          "type": "object",
          "properties": { "r": { "type": "number" }, "g": { "type": "number" }, "b": { "type": "number" }, "a": { "type": "number" } },
          "description": "Deep water tint color (RGBA 0-1)."
        },
        "max_visibility": {
          "type": "number",
          "description": "Maximum underwater visibility distance."
        }
      },
      "additionalProperties": false,
      "required": ["actor"]
    }
  },
  {
    "name": "water.set_flow",
    "description": "Configure flow map / flow settings on a river water body.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": {
          "type": "string",
          "description": "River water body actor name/label."
        },
        "flow_velocity": {
          "type": "number",
          "description": "River flow velocity."
        },
        "flow_direction": {
          "type": "string",
          "enum": ["forward", "backward"],
          "description": "Direction of flow along the spline."
        }
      },
      "additionalProperties": false,
      "required": ["actor"]
    }
  },
  {
    "name": "water.create_zone",
    "description": "Create a Water Zone actor to manage water rendering for a section of the level.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "required": ["x", "y", "z"]
        },
        "label": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "required": ["location"]
    }
  },
  {
    "name": "water.set_buoyancy",
    "description": "Configure buoyancy settings on an actor for water interaction. Uses UBuoyancyComponent.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": {
          "type": "string",
          "description": "Actor name/label to add buoyancy to."
        },
        "buoyancy_coefficient": {
          "type": "number",
          "description": "Overall buoyancy strength.",
          "default": 1.0
        },
        "num_pontoons": {
          "type": "integer",
          "description": "Number of buoyancy pontoon points.",
          "default": 1
        },
        "water_drag": {
          "type": "number",
          "description": "Drag when submerged.",
          "default": 0.5
        }
      },
      "additionalProperties": false,
      "required": ["actor"]
    }
  },

  {
    "_comment": "=== AUDIO / METASOUND SYSTEM === (API: Plugins/MetasoundEngine, Plugins/MetasoundFrontend, Plugins/AudioModulation, Runtime/AudioMixer, Plugins/Synthesis)",
    "name": "audio.create_sound_cue",
    "description": "Create a new Sound Cue asset. Uses USoundCueFactory.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Content folder path."
        },
        "asset_name": {
          "type": "string",
          "description": "Name for the new Sound Cue."
        },
        "sound_waves": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Array of SoundWave asset paths to include."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name", "sound_waves"]
    }
  },
  {
    "name": "audio.metasound_add_node",
    "description": "Add a node to a MetaSound graph. Uses FMetasoundFrontendDocument.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "metasound_asset": {
          "type": "string",
          "description": "Asset path to the MetaSound."
        },
        "node_class": {
          "type": "string",
          "description": "Class name of the node to add (e.g. 'Trigger Repeat', 'Oscillator', 'ADSR Envelope')."
        },
        "position_x": {
          "type": "integer",
          "description": "Node X position in graph.",
          "default": 0
        },
        "position_y": {
          "type": "integer",
          "description": "Node Y position in graph.",
          "default": 0
        }
      },
      "additionalProperties": false,
      "required": ["metasound_asset", "node_class"]
    }
  },
  {
    "name": "audio.metasound_connect",
    "description": "Connect two nodes in a MetaSound graph.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "metasound_asset": {
          "type": "string",
          "description": "Asset path to the MetaSound."
        },
        "source_node": {
          "type": "string",
          "description": "Source node name/id."
        },
        "source_pin": {
          "type": "string",
          "description": "Output pin name on source node."
        },
        "target_node": {
          "type": "string",
          "description": "Target node name/id."
        },
        "target_pin": {
          "type": "string",
          "description": "Input pin name on target node."
        }
      },
      "additionalProperties": false,
      "required": ["metasound_asset", "source_node", "source_pin", "target_node", "target_pin"]
    }
  },
  {
    "name": "audio.metasound_set_input",
    "description": "Set a default value on a MetaSound input parameter.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "metasound_asset": {
          "type": "string",
          "description": "Asset path to the MetaSound."
        },
        "input_name": {
          "type": "string",
          "description": "Name of the input to set."
        },
        "value": {
          "description": "Default value for the input (type depends on input)."
        },
        "value_type": {
          "type": "string",
          "enum": ["float", "int32", "bool", "string", "audio"],
          "description": "Data type of the value."
        }
      },
      "additionalProperties": false,
      "required": ["metasound_asset", "input_name", "value"]
    }
  },
  {
    "name": "audio.set_attenuation",
    "description": "Configure sound attenuation settings on an audio component or attenuation asset.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "target": {
          "type": "string",
          "description": "Actor name/label with audio, or Attenuation asset path."
        },
        "inner_radius": {
          "type": "number",
          "description": "Distance at which sound begins to attenuate."
        },
        "falloff_distance": {
          "type": "number",
          "description": "Distance over which sound fades to silence."
        },
        "attenuation_function": {
          "type": "string",
          "enum": ["linear", "logarithmic", "inverse", "log_reverse", "natural_sound", "custom"],
          "description": "Attenuation falloff curve type."
        },
        "spatialize": {
          "type": "boolean",
          "description": "Enable spatialization.",
          "default": true
        },
        "occlusion": {
          "type": "boolean",
          "description": "Enable occlusion traces.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["target"]
    }
  },
  {
    "name": "audio.set_modulation",
    "description": "Configure Audio Modulation (control bus, mix) for runtime audio parameter control. Uses Plugins/AudioModulation.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "control_bus_name": {
          "type": "string",
          "description": "Name of the control bus to create or modify."
        },
        "default_value": {
          "type": "number",
          "description": "Default value (0.0-1.0)."
        },
        "mix_name": {
          "type": "string",
          "description": "Control Bus Mix to add this bus to."
        }
      },
      "additionalProperties": false,
      "required": ["control_bus_name"]
    }
  },
  {
    "name": "audio.set_concurrency",
    "description": "Configure Sound Concurrency settings (max instances, resolution rules).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Concurrency asset path, or path to create new."
        },
        "max_count": {
          "type": "integer",
          "description": "Maximum concurrent instances."
        },
        "resolution_rule": {
          "type": "string",
          "enum": ["prevent_new", "stop_oldest", "stop_farthest", "stop_lowest_priority", "stop_quietest"],
          "description": "How to handle exceeding max count."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "max_count"]
    }
  },
  {
    "name": "audio.open",
    "description": "Open an audio asset (Sound Cue, MetaSound, Sound Wave) in the editor.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Asset path to open."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "audio.validate",
    "description": "Validate audio assets and MetaSound graphs for broken connections, missing references.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Audio asset path to validate. Omit to validate all."
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== GAMEPLAY ABILITY SYSTEM (GAS) === (API: Plugins/GameplayAbilities, Plugins/GameplayAbilitiesEditor)",
    "name": "gas.create_ability",
    "description": "Create a new Gameplay Ability Blueprint. Uses UGameplayAbilityBlueprint.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Content folder path."
        },
        "asset_name": {
          "type": "string",
          "description": "Name of the ability."
        },
        "parent_class": {
          "type": "string",
          "description": "Parent class (default: GameplayAbility).",
          "default": "GameplayAbility"
        },
        "ability_tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Gameplay tags to assign to this ability."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name"]
    }
  },
  {
    "name": "gas.create_effect",
    "description": "Create a new Gameplay Effect Blueprint for attribute modification. Uses UGameplayEffect.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Content folder path."
        },
        "asset_name": {
          "type": "string",
          "description": "Name of the Gameplay Effect."
        },
        "duration_policy": {
          "type": "string",
          "enum": ["instant", "has_duration", "infinite"],
          "description": "Duration policy."
        },
        "modifiers": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "attribute": { "type": "string", "description": "Attribute to modify (e.g. Health, Mana)." },
              "operation": { "type": "string", "enum": ["add", "multiply", "divide", "override"] },
              "magnitude_type": { "type": "string", "enum": ["scalable_float", "attribute_based", "custom_calculation", "set_by_caller"] },
              "magnitude_value": { "type": "number" }
            },
            "required": ["attribute", "operation"]
          },
          "description": "Attribute modifiers."
        },
        "period": {
          "type": "number",
          "description": "Period for periodic effects (seconds)."
        },
        "stacking_type": {
          "type": "string",
          "enum": ["none", "aggregate_by_source", "aggregate_by_target"],
          "description": "Stacking policy."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name", "duration_policy"]
    }
  },
  {
    "name": "gas.create_attribute_set",
    "description": "Create a new Attribute Set Blueprint. Uses UAttributeSet.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Content folder path."
        },
        "asset_name": {
          "type": "string",
          "description": "Name of the Attribute Set."
        },
        "attributes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string", "description": "Attribute name (e.g. Health, MaxHealth, Mana)." },
              "default_value": { "type": "number", "description": "Default value.", "default": 0.0 },
              "max_value": { "type": "number", "description": "Optional maximum value." }
            },
            "required": ["name"]
          },
          "description": "Attributes to define in this set."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name", "attributes"]
    }
  },
  {
    "name": "gas.grant_ability",
    "description": "Grant an ability to an actor's AbilitySystemComponent at the specified level.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": {
          "type": "string",
          "description": "Actor name/label with an AbilitySystemComponent."
        },
        "ability_class": {
          "type": "string",
          "description": "Class path of the GameplayAbility to grant."
        },
        "level": {
          "type": "integer",
          "description": "Ability level.",
          "default": 1
        },
        "input_id": {
          "type": "integer",
          "description": "Optional input binding ID for activation."
        }
      },
      "additionalProperties": false,
      "required": ["actor", "ability_class"]
    }
  },
  {
    "name": "gas.apply_effect",
    "description": "Apply a Gameplay Effect to an actor.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": {
          "type": "string",
          "description": "Target actor name/label."
        },
        "effect_class": {
          "type": "string",
          "description": "Class path of the GameplayEffect to apply."
        },
        "level": {
          "type": "number",
          "description": "Effect level.",
          "default": 1.0
        },
        "instigator": {
          "type": "string",
          "description": "Instigator actor name/label."
        }
      },
      "additionalProperties": false,
      "required": ["actor", "effect_class"]
    }
  },
  {
    "name": "gas.set_attribute",
    "description": "Directly set an attribute value on an actor's AbilitySystemComponent.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": {
          "type": "string",
          "description": "Actor name/label."
        },
        "attribute_set": {
          "type": "string",
          "description": "Attribute Set class name."
        },
        "attribute_name": {
          "type": "string",
          "description": "Attribute name (e.g. Health)."
        },
        "value": {
          "type": "number",
          "description": "Value to set."
        }
      },
      "additionalProperties": false,
      "required": ["actor", "attribute_name", "value"]
    }
  },
  {
    "name": "gas.add_gameplay_cue",
    "description": "Add a Gameplay Cue tag mapping for visual/audio feedback on gameplay events.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "cue_tag": {
          "type": "string",
          "description": "Gameplay Cue tag (e.g. GameplayCue.Damage.Fire)."
        },
        "notify_class": {
          "type": "string",
          "description": "GameplayCueNotify class path to spawn."
        }
      },
      "additionalProperties": false,
      "required": ["cue_tag"]
    }
  },
  {
    "name": "gas.validate",
    "description": "Validate GAS setup: check ability tags, effect stacking, attribute sets, and cue mappings.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "scope": {
          "type": "string",
          "enum": ["all", "abilities", "effects", "attributes", "cues"],
          "description": "What to validate.",
          "default": "all"
        },
        "asset_path": {
          "type": "string",
          "description": "Specific asset to validate. Omit = validate all."
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== LIVE LINK SYSTEM === (API: Runtime/LiveLinkInterface, Plugins/LiveLinkAnimationCore, Plugins/LiveLinkMovieScene)",
    "name": "livelink.add_source",
    "description": "Add a Live Link source for real-time data streaming. Uses ILiveLinkClient.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source_type": {
          "type": "string",
          "enum": ["message_bus", "freed", "mvn", "optitrack", "custom"],
          "description": "Type of Live Link source."
        },
        "machine_address": {
          "type": "string",
          "description": "IP address or hostname of the source machine."
        },
        "port": {
          "type": "integer",
          "description": "Port number if applicable."
        },
        "source_name": {
          "type": "string",
          "description": "Friendly name for the source."
        }
      },
      "additionalProperties": false,
      "required": ["source_type"]
    }
  },
  {
    "name": "livelink.remove_source",
    "description": "Remove a Live Link source by name or GUID.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source_name": {
          "type": "string",
          "description": "Name of the source to remove."
        }
      },
      "additionalProperties": false,
      "required": ["source_name"]
    }
  },
  {
    "name": "livelink.list_sources",
    "description": "List all active Live Link sources and their subjects.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "livelink.map_subject",
    "description": "Map a Live Link subject to a skeletal mesh or actor for retargeting.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "subject_name": {
          "type": "string",
          "description": "Live Link subject name."
        },
        "target_actor": {
          "type": "string",
          "description": "Actor name/label to drive with this subject."
        },
        "retarget_asset": {
          "type": "string",
          "description": "Optional retarget asset path for bone remapping."
        }
      },
      "additionalProperties": false,
      "required": ["subject_name", "target_actor"]
    }
  },
  {
    "name": "livelink.set_preset",
    "description": "Apply or save a Live Link preset configuration.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "preset_path": {
          "type": "string",
          "description": "Asset path to the Live Link Preset."
        },
        "action": {
          "type": "string",
          "enum": ["apply", "save"],
          "description": "Whether to apply a preset or save current config as preset."
        }
      },
      "additionalProperties": false,
      "required": ["preset_path", "action"]
    }
  },

  {
    "_comment": "=== TAKE RECORDER === (API: Plugins/TakeRecorder, Plugins/TakesCore, Plugins/TakeTrackRecorders, Plugins/TakeMovieScene)",
    "name": "take.start_recording",
    "description": "Start a Take Recorder session. Uses UTakeRecorder.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "slate_name": {
          "type": "string",
          "description": "Slate/scene name for this take."
        },
        "take_number": {
          "type": "integer",
          "description": "Take number. Omit for auto-increment."
        },
        "sources": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type": { "type": "string", "enum": ["actor", "world", "camera", "audio", "live_link"] },
              "target": { "type": "string", "description": "Actor or source name to record." }
            },
            "required": ["type"]
          },
          "description": "Recording sources to include."
        },
        "record_to_possessable": {
          "type": "boolean",
          "description": "Record as possessable (true) or spawnable (false).",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["slate_name"]
    }
  },
  {
    "name": "take.stop_recording",
    "description": "Stop the current Take Recorder session.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "take.list_takes",
    "description": "List all recorded takes in the project.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "slate_filter": {
          "type": "string",
          "description": "Filter by slate name. Omit = show all."
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "take.open",
    "description": "Open a recorded take in the Sequencer.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "take_asset": {
          "type": "string",
          "description": "Asset path to the take's Level Sequence."
        }
      },
      "additionalProperties": false,
      "required": ["take_asset"]
    }
  },
  {
    "name": "take.set_settings",
    "description": "Configure Take Recorder settings before recording.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "countdown_seconds": {
          "type": "number",
          "description": "Countdown before recording starts."
        },
        "auto_save": {
          "type": "boolean",
          "description": "Auto-save after recording stops.",
          "default": true
        },
        "max_duration": {
          "type": "number",
          "description": "Maximum recording duration in seconds. 0 = unlimited."
        },
        "output_directory": {
          "type": "string",
          "description": "Content directory for saved takes."
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== CONTROL RIG === (API: Plugins/ControlRig, Plugins/ControlRigEditor, Plugins/ControlRigDeveloper)",
    "name": "controlrig.create",
    "description": "Create a new Control Rig Blueprint for procedural animation. Uses UControlRigBlueprint.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Content folder path."
        },
        "asset_name": {
          "type": "string",
          "description": "Name for the Control Rig."
        },
        "skeleton": {
          "type": "string",
          "description": "Skeletal Mesh or Skeleton asset to base the rig on."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name", "skeleton"]
    }
  },

  {
    "name": "controlrig.add_bone",
    "description": "Add a bone element to a Control Rig hierarchy.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "rig_asset": {
          "type": "string"
        },
        "bone_name": {
          "type": "string"
        },
        "parent": {
          "type": "string",
          "description": "Parent element name."
        },
        "initial_transform": {
          "type": "object",
          "properties": {
            "location": { "type": "object", "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } } },
            "rotation": { "type": "object", "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } } }
          }
        }
      },
      "additionalProperties": false,
      "required": ["rig_asset", "bone_name"]
    }
  },
  {
    "name": "controlrig.add_rig_unit",
    "description": "Add a Rig Unit (solver node) to the Control Rig graph (FK, IK, CCDIK, FABRIK, etc.).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "rig_asset": {
          "type": "string"
        },
        "unit_type": {
          "type": "string",
          "description": "Rig Unit class name (e.g. RigUnit_TwoBoneIKSimple, RigUnit_FABRIK, RigUnit_SetTransform)."
        },
        "position_x": {
          "type": "integer",
          "default": 0
        },
        "position_y": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false,
      "required": ["rig_asset", "unit_type"]
    }
  },


  {
    "_comment": "=== IK RIG === (API: Plugins/IKRig, Plugins/IKRigEditor)",
    "name": "ikrig.create",
    "description": "Create a new IK Rig asset. Uses UIKRigDefinition.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" },
        "skeletal_mesh": {
          "type": "string",
          "description": "Preview skeletal mesh asset path."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name", "skeletal_mesh"]
    }
  },
  {
    "name": "ikrig.add_solver",
    "description": "Add an IK solver to an IK Rig (FullBody, LimbIK, PBIK, etc.).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "rig_asset": { "type": "string" },
        "solver_type": {
          "type": "string",
          "enum": ["full_body_ik", "limb_ik", "pbik", "aim", "look_at", "spline_ik"],
          "description": "Type of IK solver."
        },
        "solver_name": { "type": "string" },
        "root_bone": {
          "type": "string",
          "description": "Root bone for the IK chain."
        },
        "end_bone": {
          "type": "string",
          "description": "End effector bone."
        }
      },
      "additionalProperties": false,
      "required": ["rig_asset", "solver_type", "root_bone", "end_bone"]
    }
  },
  {
    "name": "ikrig.add_goal",
    "description": "Add an IK goal (target) to a solver in an IK Rig.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "rig_asset": { "type": "string" },
        "goal_name": { "type": "string" },
        "bone_name": {
          "type": "string",
          "description": "Bone this goal drives."
        },
        "solver_name": {
          "type": "string",
          "description": "Name of the solver this goal belongs to."
        }
      },
      "additionalProperties": false,
      "required": ["rig_asset", "goal_name", "bone_name"]
    }
  },
  {
    "name": "ikrig.create_retargeter",
    "description": "Create an IK Retargeter asset for bone mapping between two skeletons. Uses UIKRetargeter.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" },
        "source_rig": {
          "type": "string",
          "description": "Source IK Rig asset path."
        },
        "target_rig": {
          "type": "string",
          "description": "Target IK Rig asset path."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name", "source_rig", "target_rig"]
    }
  },
  {
    "name": "ikrig.add_chain_mapping",
    "description": "Add a chain mapping between source and target IK Rigs in a Retargeter.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "retargeter_asset": { "type": "string" },
        "source_chain": { "type": "string" },
        "target_chain": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["retargeter_asset", "source_chain", "target_chain"]
    }
  },

  {
    "_comment": "=== ENHANCED INPUT === (API: Plugins/EnhancedInput)",
    "name": "enhancedinput.create_action",
    "description": "Create a new Input Action asset. Uses UInputAction.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" },
        "value_type": {
          "type": "string",
          "enum": ["bool", "axis1d", "axis2d", "axis3d"],
          "description": "Input value type."
        },
        "consume_input": {
          "type": "boolean",
          "default": true
        },
        "triggers": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": ["down", "pressed", "released", "hold", "hold_and_release", "tap", "pulse", "chorded"]
          },
          "description": "Trigger types to add."
        },
        "modifiers": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": ["dead_zone", "scalar", "negate", "smooth", "response_curve", "swizzle_axis"]
          },
          "description": "Input modifiers to add."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name", "value_type"]
    }
  },
  {
    "name": "enhancedinput.create_mapping_context",
    "description": "Create a new Input Mapping Context asset. Uses UInputMappingContext.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" },
        "mappings": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "action": { "type": "string", "description": "Input Action asset path." },
              "key": { "type": "string", "description": "Key name (e.g. W, SpaceBar, Gamepad_LeftStick_X, LeftMouseButton)." },
              "modifiers": {
                "type": "array",
                "items": { "type": "string" },
                "description": "Modifier class names."
              },
              "triggers": {
                "type": "array",
                "items": { "type": "string" },
                "description": "Trigger class names."
              }
            },
            "required": ["action", "key"]
          },
          "description": "Key-to-action mappings."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name"]
    }
  },
  {
    "name": "enhancedinput.add_mapping",
    "description": "Add a key mapping to an existing Input Mapping Context.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "context_asset": {
          "type": "string",
          "description": "Input Mapping Context asset path."
        },
        "action": {
          "type": "string",
          "description": "Input Action asset path."
        },
        "key": {
          "type": "string",
          "description": "Key name."
        },
        "modifiers": {
          "type": "array",
          "items": { "type": "string" }
        },
        "triggers": {
          "type": "array",
          "items": { "type": "string" }
        }
      },
      "additionalProperties": false,
      "required": ["context_asset", "action", "key"]
    }
  },
  {
    "name": "enhancedinput.open",
    "description": "Open Enhanced Input asset in editor.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },

  {
    "_comment": "=== SMART OBJECTS === (API: Plugins/SmartObjectsModule, Plugins/SmartObjectsEditorModule)",
    "name": "smartobject.create_definition",
    "description": "Create a new Smart Object Definition asset. Uses USmartObjectDefinition.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" },
        "slots": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "slot_type": { "type": "string", "description": "Gameplay tag for slot type." },
              "offset": {
                "type": "object",
                "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
              },
              "rotation": {
                "type": "object",
                "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
              },
              "user_tag_filter": {
                "type": "array",
                "items": { "type": "string" },
                "description": "Required gameplay tags on the user."
              }
            },
            "required": ["slot_type"]
          },
          "description": "Interaction slots in this definition."
        },
        "activity_tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Gameplay tags describing what this smart object provides."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name"]
    }
  },
  {
    "name": "smartobject.add_slot",
    "description": "Add an interaction slot to an existing Smart Object Definition.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "definition_asset": { "type": "string" },
        "slot_type": { "type": "string" },
        "offset": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
        },
        "behavior_definition": {
          "type": "string",
          "description": "Behavior Definition asset path for this slot."
        }
      },
      "additionalProperties": false,
      "required": ["definition_asset", "slot_type"]
    }
  },
  {
    "name": "smartobject.set_preconditions",
    "description": "Set preconditions (gameplay tag requirements, world conditions) on a Smart Object slot.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "definition_asset": { "type": "string" },
        "slot_index": { "type": "integer" },
        "required_tags": {
          "type": "array",
          "items": { "type": "string" }
        },
        "blocked_tags": {
          "type": "array",
          "items": { "type": "string" }
        }
      },
      "additionalProperties": false,
      "required": ["definition_asset", "slot_index"]
    }
  },
  {
    "name": "smartobject.validate",
    "description": "Validate Smart Object definitions for missing slots, invalid tags.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "definition_asset": { "type": "string" }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== MOTION WARPING === (API: Plugins/MotionWarping, Plugins/AnimationWarpingRuntime)",
    "name": "motionwarp.add_target",
    "description": "Add a motion warping target to an actor. Uses UMotionWarpingComponent.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": {
          "type": "string",
          "description": "Actor with MotionWarpingComponent."
        },
        "warp_target_name": {
          "type": "string",
          "description": "Name tag for the warp target (matches anim notify)."
        },
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "required": ["x", "y", "z"]
        },
        "rotation": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
        }
      },
      "additionalProperties": false,
      "required": ["actor", "warp_target_name", "location"]
    }
  },
  {
    "name": "motionwarp.remove_target",
    "description": "Remove a motion warping target by name.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "warp_target_name": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["actor", "warp_target_name"]
    }
  },
  {
    "name": "motionwarp.add_notify",
    "description": "Add a MotionWarping anim notify state to an animation montage.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "montage_asset": {
          "type": "string",
          "description": "AnimMontage asset path."
        },
        "warp_target_name": {
          "type": "string",
          "description": "Warp target name to reference."
        },
        "start_time": {
          "type": "number",
          "description": "Start time of the notify (seconds)."
        },
        "end_time": {
          "type": "number",
          "description": "End time of the notify (seconds)."
        },
        "warp_translation": {
          "type": "boolean",
          "default": true
        },
        "warp_rotation": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["montage_asset", "warp_target_name", "start_time", "end_time"]
    }
  },

  {
    "_comment": "=== MODELING TOOLS === (API: Plugins/MeshModelingTools, Plugins/DynamicMesh, Runtime/GeometryCore)",
    "name": "modeling.boolean",
    "description": "Perform CSG boolean operation between meshes (union, subtract, intersect). Uses UBooleanMeshesTool.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": {
          "type": "string",
          "enum": ["union", "subtract", "intersect"],
          "description": "Boolean operation type."
        },
        "mesh_a": {
          "type": "string",
          "description": "First mesh actor name/label."
        },
        "mesh_b": {
          "type": "string",
          "description": "Second mesh actor name/label."
        },
        "output_name": {
          "type": "string",
          "description": "Name for the output mesh."
        }
      },
      "additionalProperties": false,
      "required": ["operation", "mesh_a", "mesh_b"]
    }
  },
  {
    "name": "modeling.remesh",
    "description": "Remesh a static mesh actor with target triangle count. Uses URemeshMeshTool.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": {
          "type": "string",
          "description": "Mesh actor name/label."
        },
        "target_triangle_count": {
          "type": "integer",
          "description": "Target number of triangles."
        },
        "smoothing_type": {
          "type": "string",
          "enum": ["none", "uniform", "cotangent", "mean_value"],
          "description": "Smoothing algorithm during remesh."
        },
        "smoothing_rate": {
          "type": "number",
          "description": "Smoothing strength (0.0-1.0)."
        },
        "preserve_sharp_edges": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["actor", "target_triangle_count"]
    }
  },
  {
    "name": "modeling.simplify",
    "description": "Simplify/decimate a mesh. Uses USimplifyMeshTool.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "target_percentage": {
          "type": "number",
          "description": "Target percentage of original triangles (0.0-1.0)."
        },
        "method": {
          "type": "string",
          "enum": ["qem", "attribute_aware", "volume_preserving"],
          "description": "Simplification algorithm."
        },
        "preserve_boundaries": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["actor", "target_percentage"]
    }
  },
  {
    "name": "modeling.extrude",
    "description": "Extrude faces of a dynamic mesh.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "distance": {
          "type": "number",
          "description": "Extrusion distance."
        },
        "face_selection": {
          "type": "string",
          "enum": ["all", "top", "bottom", "selected"],
          "description": "Which faces to extrude."
        }
      },
      "additionalProperties": false,
      "required": ["actor", "distance"]
    }
  },
  {
    "name": "modeling.generate_uv",
    "description": "Generate UV unwrap for a mesh. Uses UAutoUnwrapMeshTool.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "method": {
          "type": "string",
          "enum": ["auto", "box", "cylinder", "planar", "exp_map", "xatlas"],
          "description": "UV generation method."
        },
        "uv_channel": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false,
      "required": ["actor", "method"]
    }
  },
  {
    "name": "modeling.create_primitive",
    "description": "Create a primitive shape as a dynamic mesh actor.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "shape": {
          "type": "string",
          "enum": ["box", "sphere", "cylinder", "cone", "torus", "plane", "stairs", "arrow"],
          "description": "Primitive shape type."
        },
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "required": ["x", "y", "z"]
        },
        "dimensions": {
          "type": "object",
          "properties": {
            "width": { "type": "number" },
            "height": { "type": "number" },
            "depth": { "type": "number" },
            "radius": { "type": "number" },
            "subdivisions": { "type": "integer" }
          }
        }
      },
      "additionalProperties": false,
      "required": ["shape", "location"]
    }
  },
  {
    "name": "modeling.voxel_merge",
    "description": "Merge multiple meshes using voxel remeshing. Uses UVoxelMergeMeshesTool.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actors": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Actor names/labels to merge."
        },
        "voxel_resolution": {
          "type": "integer",
          "description": "Voxel grid resolution.",
          "default": 128
        },
        "output_name": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["actors"]
    }
  },

  {
    "_comment": "=== SPLINE TOOLS ===",
    "name": "spline.create",
    "description": "Spawn an actor with a spline component in the level.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "label": { "type": "string" },
        "points": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "location": { "type": "object", "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }, "required": ["x", "y", "z"] },
              "arrive_tangent": { "type": "object", "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } } },
              "leave_tangent": { "type": "object", "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } } }
            },
            "required": ["location"]
          },
          "description": "Spline control points."
        },
        "closed_loop": {
          "type": "boolean",
          "default": false
        },
        "spline_type": {
          "type": "string",
          "enum": ["linear", "curve", "constant"],
          "default": "curve"
        }
      },
      "additionalProperties": false,
      "required": ["points"]
    }
  },
  {
    "name": "spline.add_point",
    "description": "Add a control point to an existing spline.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "required": ["x", "y", "z"]
        },
        "index": {
          "type": "integer",
          "description": "Insert at this index. -1 = append."
        }
      },
      "additionalProperties": false,
      "required": ["actor", "location"]
    }
  },
  {
    "name": "spline.remove_point",
    "description": "Remove a control point from a spline.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "index": { "type": "integer" }
      },
      "additionalProperties": false,
      "required": ["actor", "index"]
    }
  },
  {
    "name": "spline.set_point",
    "description": "Set position/tangent of a spline control point.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "index": { "type": "integer" },
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
        },
        "arrive_tangent": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
        },
        "leave_tangent": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
        },
        "point_type": {
          "type": "string",
          "enum": ["linear", "curve", "constant", "curve_clamped", "curve_custom_tangent"]
        }
      },
      "additionalProperties": false,
      "required": ["actor", "index"]
    }
  },
  {
    "name": "spline.get_info",
    "description": "Get information about a spline (point count, length, closed state).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["actor"]
    }
  },
  {
    "name": "spline.sample",
    "description": "Sample a position/rotation along a spline at a given distance or ratio.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "distance": {
          "type": "number",
          "description": "Distance along spline to sample."
        },
        "ratio": {
          "type": "number",
          "description": "Normalized position (0.0-1.0). Provide distance OR ratio."
        },
        "coordinate_space": {
          "type": "string",
          "enum": ["world", "local"],
          "default": "world"
        }
      },
      "additionalProperties": false,
      "required": ["actor"]
    }
  },

  {
    "_comment": "=== NETWORKING / REPLICATION === (API: Runtime/NetCore, Plugins/ReplicationGraph, Runtime/Networking)",
    "name": "networking.set_replication",
    "description": "Configure replication settings on an actor (replicated, net role, update frequency).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "replicated": {
          "type": "boolean",
          "description": "Whether the actor is replicated."
        },
        "net_update_frequency": {
          "type": "number",
          "description": "Network update frequency (Hz)."
        },
        "net_priority": {
          "type": "number",
          "description": "Network priority (higher = more updates)."
        },
        "always_relevant": {
          "type": "boolean",
          "default": false
        },
        "net_dormancy": {
          "type": "string",
          "enum": ["never", "awake", "dormant_all", "dormant_partial", "initial"],
          "description": "Dormancy state."
        }
      },
      "additionalProperties": false,
      "required": ["actor"]
    }
  },
  {
    "name": "networking.add_replicated_property",
    "description": "Mark a Blueprint variable as replicated with condition and notification.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint": { "type": "string" },
        "variable_name": { "type": "string" },
        "replication_condition": {
          "type": "string",
          "enum": ["none", "initial_only", "owner_only", "skip_owner", "simulated_only", "autonomous_only", "simulated_or_physics", "initial_or_owner", "custom", "replay_or_owner", "replay_only"],
          "description": "Replication condition."
        },
        "rep_notify": {
          "type": "boolean",
          "description": "Create an OnRep notification function.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["blueprint", "variable_name"]
    }
  },
  {
    "name": "networking.add_rpc",
    "description": "Add an RPC function to a Blueprint (Server, Client, Multicast).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint": { "type": "string" },
        "function_name": { "type": "string" },
        "rpc_type": {
          "type": "string",
          "enum": ["server", "client", "multicast"],
          "description": "RPC execution authority."
        },
        "reliable": {
          "type": "boolean",
          "description": "Whether the RPC is reliable.",
          "default": false
        },
        "validation": {
          "type": "boolean",
          "description": "Add WithValidation (for Server RPCs).",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["blueprint", "function_name", "rpc_type"]
    }
  },
  {
    "name": "networking.set_net_relevancy",
    "description": "Configure network relevancy settings on an actor.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "only_relevant_to_owner": {
          "type": "boolean",
          "default": false
        },
        "net_cull_distance": {
          "type": "number",
          "description": "Distance beyond which the actor is not relevant."
        }
      },
      "additionalProperties": false,
      "required": ["actor"]
    }
  },

  {
    "_comment": "=== SCENE CAPTURE ===",
    "name": "scenecapture.create_2d",
    "description": "Spawn a SceneCapture2D actor. Uses ASceneCapture2D.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "required": ["x", "y", "z"]
        },
        "rotation": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
        },
        "label": { "type": "string" },
        "resolution_x": { "type": "integer", "default": 1024 },
        "resolution_y": { "type": "integer", "default": 1024 },
        "capture_source": {
          "type": "string",
          "enum": ["scene_color_hdr", "scene_color_scene_depth", "scene_depth", "final_color_ldr", "base_color", "normal", "scene_depth_aux"],
          "default": "final_color_ldr"
        },
        "capture_every_frame": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["location"]
    }
  },
  {
    "name": "scenecapture.create_cube",
    "description": "Spawn a SceneCaptureCube actor for 360 capture. Uses ASceneCaptureCube.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "required": ["x", "y", "z"]
        },
        "label": { "type": "string" },
        "resolution": { "type": "integer", "default": 512 },
        "capture_every_frame": { "type": "boolean", "default": false }
      },
      "additionalProperties": false,
      "required": ["location"]
    }
  },
  {
    "name": "scenecapture.capture_once",
    "description": "Trigger a single capture on a SceneCapture actor.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "output_path": {
          "type": "string",
          "description": "Optional file path to export the capture as image."
        }
      },
      "additionalProperties": false,
      "required": ["actor"]
    }
  },

  {
    "_comment": "=== PROCEDURAL MESH ===",
    "name": "procmesh.create",
    "description": "Spawn a ProceduralMeshComponent actor with custom geometry.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "label": { "type": "string" },
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "required": ["x", "y", "z"]
        },
        "vertices": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
          },
          "description": "Vertex positions."
        },
        "triangles": {
          "type": "array",
          "items": { "type": "integer" },
          "description": "Triangle indices (groups of 3)."
        },
        "normals": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
          },
          "description": "Per-vertex normals. Optional (auto-computed)."
        },
        "uvs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": { "u": { "type": "number" }, "v": { "type": "number" } }
          },
          "description": "UV coordinates."
        },
        "material": {
          "type": "string",
          "description": "Material asset path."
        },
        "enable_collision": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["location", "vertices", "triangles"]
    }
  },
  {
    "name": "procmesh.update_section",
    "description": "Update a mesh section on an existing ProceduralMesh.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "section_index": { "type": "integer", "default": 0 },
        "vertices": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
          }
        },
        "triangles": {
          "type": "array",
          "items": { "type": "integer" }
        }
      },
      "additionalProperties": false,
      "required": ["actor", "vertices", "triangles"]
    }
  },
  {
    "name": "procmesh.convert_to_static",
    "description": "Convert a ProceduralMesh to a StaticMesh asset.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["actor", "asset_path", "asset_name"]
    }
  },

  {
    "_comment": "=== MEDIA FRAMEWORK === (API: Runtime/MediaAssets, Plugins/MediaIOCore, Plugins/MediaPlate)",
    "name": "media.create_player",
    "description": "Create a Media Player asset and associated Media Texture. Uses UMediaPlayerFactory.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" },
        "create_texture": {
          "type": "boolean",
          "description": "Also create a linked Media Texture asset.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name"]
    }
  },
  {
    "name": "media.create_source",
    "description": "Create a Media Source asset (file, stream, URL).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" },
        "source_type": {
          "type": "string",
          "enum": ["file", "stream", "url", "img_sequence", "platform_media"],
          "description": "Type of media source."
        },
        "file_path": {
          "type": "string",
          "description": "Path to the media file (for file type)."
        },
        "url": {
          "type": "string",
          "description": "URL for stream or url type."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name", "source_type"]
    }
  },
  {
    "name": "media.spawn_plate",
    "description": "Spawn a Media Plate actor in the level for in-world media playback.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "required": ["x", "y", "z"]
        },
        "media_source": {
          "type": "string",
          "description": "Media Source asset path."
        },
        "label": { "type": "string" },
        "auto_play": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["location", "media_source"]
    }
  },
  {
    "name": "media.open",
    "description": "Open a media asset in the Media Editor.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },

  {
    "_comment": "=== PLUGIN MANAGEMENT === (API: Plugins/PluginBrowser, Plugins/PluginUtils, Runtime/Projects)",
    "name": "plugin.list",
    "description": "List all available plugins (enabled and disabled).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "filter": {
          "type": "string",
          "enum": ["all", "enabled", "disabled", "project", "engine"],
          "description": "Filter plugins by status.",
          "default": "all"
        },
        "category": {
          "type": "string",
          "description": "Filter by category name."
        },
        "search": {
          "type": "string",
          "description": "Search term for plugin name."
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "plugin.enable",
    "description": "Enable a plugin in the project.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "plugin_name": {
          "type": "string",
          "description": "Plugin name to enable."
        },
        "restart_required": {
          "type": "boolean",
          "description": "Whether an editor restart is needed (output)."
        }
      },
      "additionalProperties": false,
      "required": ["plugin_name"]
    }
  },
  {
    "name": "plugin.disable",
    "description": "Disable a plugin in the project.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "plugin_name": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["plugin_name"]
    }
  },
  {
    "name": "plugin.get_info",
    "description": "Get detailed info about a specific plugin (version, description, dependencies).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "plugin_name": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["plugin_name"]
    }
  },
  {
    "name": "plugin.create",
    "description": "Create a new blank plugin in the project's Plugins directory.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "plugin_name": { "type": "string" },
        "friendly_name": { "type": "string" },
        "description": { "type": "string" },
        "author": { "type": "string" },
        "template": {
          "type": "string",
          "enum": ["blank", "blueprint_library", "editor_toolbar_button", "editor_standalone_window", "content_only", "third_party_library"],
          "description": "Plugin template to use."
        }
      },
      "additionalProperties": false,
      "required": ["plugin_name"]
    }
  },

  {
    "_comment": "=== LEVEL SNAPSHOTS === (API: Plugins/LevelSnapshots, Plugins/LevelSnapshotsEditor)",
    "name": "levelsnapshot.capture",
    "description": "Capture a Level Snapshot of the current level state. Uses ULevelSnapshotsModule.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "snapshot_name": {
          "type": "string",
          "description": "Name for the snapshot."
        },
        "description": {
          "type": "string",
          "description": "Optional description."
        },
        "asset_path": {
          "type": "string",
          "description": "Content folder to save snapshot."
        }
      },
      "additionalProperties": false,
      "required": ["snapshot_name"]
    }
  },
  {
    "name": "levelsnapshot.restore",
    "description": "Restore a Level Snapshot, applying its saved state to the current level.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "snapshot_asset": {
          "type": "string",
          "description": "Asset path to the Level Snapshot."
        },
        "filter": {
          "type": "string",
          "description": "Optional filter asset path to selectively restore."
        }
      },
      "additionalProperties": false,
      "required": ["snapshot_asset"]
    }
  },
  {
    "name": "levelsnapshot.list",
    "description": "List all Level Snapshots in the project.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "folder": {
          "type": "string",
          "description": "Content folder to search. Omit for all."
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "levelsnapshot.diff",
    "description": "Compare a Level Snapshot with the current level state and return differences.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "snapshot_asset": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["snapshot_asset"]
    }
  },

  {
    "_comment": "=== DATA VALIDATION === (API: Plugins/DataValidation)",
    "name": "datavalidation.validate_assets",
    "description": "Run Data Validation on specified assets. Uses UEditorValidatorSubsystem.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_paths": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Asset paths to validate. Empty = validate all."
        },
        "validation_usecase": {
          "type": "string",
          "enum": ["none", "save", "presubmit", "commandlet", "manual"],
          "description": "Validation use case context.",
          "default": "manual"
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "datavalidation.validate_changelists",
    "description": "Validate all assets in pending source control changelists.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "datavalidation.list_validators",
    "description": "List all registered data validators.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== VIRTUAL TEXTURING === (API: Editor/VirtualTexturingEditor)",
    "name": "virtualtexture.create_rvt",
    "description": "Create a Runtime Virtual Texture asset.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" },
        "material_type": {
          "type": "string",
          "enum": ["base_color", "base_color_normal", "base_color_normal_specular", "base_color_normal_roughness", "world_height"],
          "description": "Virtual texture content type."
        },
        "tile_size": {
          "type": "integer",
          "enum": [128, 256, 512, 1024],
          "default": 256
        },
        "tile_border_size": {
          "type": "integer",
          "default": 4
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name", "material_type"]
    }
  },
  {
    "name": "virtualtexture.spawn_volume",
    "description": "Spawn a RuntimeVirtualTextureVolume actor to define VT bounds.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "required": ["x", "y", "z"]
        },
        "rvt_asset": {
          "type": "string",
          "description": "Runtime Virtual Texture asset path."
        },
        "scale": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
        }
      },
      "additionalProperties": false,
      "required": ["location", "rvt_asset"]
    }
  },

  {
    "_comment": "=== COMMON UI === (API: Plugins/CommonUI, Plugins/CommonInput)",
    "name": "commonui.create_activatable_widget",
    "description": "Create a CommonUI Activatable Widget Blueprint.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" },
        "parent_class": {
          "type": "string",
          "enum": ["CommonActivatableWidget", "CommonUserWidget"],
          "default": "CommonActivatableWidget"
        },
        "auto_activate": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name"]
    }
  },
  {
    "name": "commonui.set_input_action",
    "description": "Set a CommonUI Input Action Data Table entry for platform-agnostic input.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "datatable_asset": {
          "type": "string",
          "description": "CommonInputActionDataTable asset path."
        },
        "action_name": { "type": "string" },
        "keyboard_key": { "type": "string" },
        "gamepad_key": { "type": "string" },
        "touch_key": { "type": "string" },
        "display_name": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["datatable_asset", "action_name"]
    }
  },
  {
    "name": "commonui.configure_styling",
    "description": "Configure CommonUI base styles (button styles, text styles, borders).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "style_asset": {
          "type": "string",
          "description": "Style asset path."
        },
        "style_type": {
          "type": "string",
          "enum": ["button", "text", "border", "loading"],
          "description": "Type of style to configure."
        },
        "properties": {
          "type": "object",
          "additionalProperties": true,
          "description": "Style property overrides."
        }
      },
      "additionalProperties": false,
      "required": ["style_asset", "style_type"]
    }
  },

  {
    "_comment": "=== COMPOSURE / COMPOSITING === (API: Plugins/Composure, Plugins/ComposureEditor)",
    "name": "composure.create_element",
    "description": "Create a Composure compositing element in the level.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "element_name": { "type": "string" },
        "element_type": {
          "type": "string",
          "enum": ["cg_layer", "media_plate", "composite", "empty"],
          "description": "Type of compositing element."
        },
        "parent_element": {
          "type": "string",
          "description": "Parent compositing element name."
        }
      },
      "additionalProperties": false,
      "required": ["element_name", "element_type"]
    }
  },
  {
    "name": "composure.add_pass",
    "description": "Add a compositing pass to a Composure element.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "element_name": { "type": "string" },
        "pass_type": {
          "type": "string",
          "enum": ["camera", "transform", "material", "media", "capture"],
          "description": "Pass type to add."
        },
        "material": {
          "type": "string",
          "description": "Material asset path (for material pass)."
        }
      },
      "additionalProperties": false,
      "required": ["element_name", "pass_type"]
    }
  },

  {
    "_comment": "=== PIXEL STREAMING === (API: Plugins/PixelStreaming2, Plugins/PixelStreaming2Core)",
    "name": "pixelstreaming.configure",
    "description": "Configure Pixel Streaming settings.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "signaling_url": {
          "type": "string",
          "description": "WebSocket signaling server URL."
        },
        "encoder": {
          "type": "string",
          "enum": ["h264", "h265", "vp8", "vp9", "av1"],
          "description": "Video encoder."
        },
        "bitrate_max": {
          "type": "integer",
          "description": "Maximum bitrate in bps."
        },
        "resolution_x": { "type": "integer" },
        "resolution_y": { "type": "integer" },
        "framerate": { "type": "integer" }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "pixelstreaming.start",
    "description": "Start Pixel Streaming.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "pixelstreaming.stop",
    "description": "Stop Pixel Streaming.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== VOLUME TOOLS ===",
    "name": "volume.create",
    "description": "Spawn a volume actor (blocking, trigger, physics, audio, post process, etc.).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "volume_type": {
          "type": "string",
          "enum": ["blocking", "trigger", "physics", "audio", "post_process", "lightmass_importance", "nav_mesh_bounds", "pain_causing", "kill_z", "camera_blocking", "precomputed_visibility", "level_streaming", "cull_distance"],
          "description": "Type of volume to spawn."
        },
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "required": ["x", "y", "z"]
        },
        "extent": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "description": "Box extent (half-size)."
        },
        "label": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["volume_type", "location"]
    }
  },
  {
    "name": "volume.set_properties",
    "description": "Configure volume-specific properties (e.g. post process settings, pain damage).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "properties": {
          "type": "object",
          "additionalProperties": true,
          "description": "Key-value property overrides specific to the volume type."
        }
      },
      "additionalProperties": false,
      "required": ["actor", "properties"]
    }
  },

  {
    "_comment": "=== DATASMITH / USD === (API: Plugins/DatasmithRuntime, Plugins/USDStage, Plugins/USDExporter)",
    "name": "datasmith.import",
    "description": "Import a Datasmith scene file into the project.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "file_path": {
          "type": "string",
          "description": "Path to .udatasmith or supported CAD file."
        },
        "destination_path": {
          "type": "string",
          "description": "Content folder for imported assets."
        },
        "import_options": {
          "type": "object",
          "properties": {
            "import_geometry": { "type": "boolean", "default": true },
            "import_materials": { "type": "boolean", "default": true },
            "import_lights": { "type": "boolean", "default": true },
            "import_cameras": { "type": "boolean", "default": true },
            "import_animations": { "type": "boolean", "default": true },
            "tessellation_factor": { "type": "number" }
          }
        }
      },
      "additionalProperties": false,
      "required": ["file_path", "destination_path"]
    }
  },
  {
    "name": "usd.open_stage",
    "description": "Open a USD stage file in the USD Stage Editor. Uses UUsdStageActor.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "file_path": {
          "type": "string",
          "description": "Path to .usd, .usda, .usdc, or .usdz file."
        },
        "root_layer": {
          "type": "string",
          "description": "Optional root layer override."
        }
      },
      "additionalProperties": false,
      "required": ["file_path"]
    }
  },
  {
    "name": "usd.export",
    "description": "Export level or selected actors to USD format.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "output_path": {
          "type": "string",
          "description": "Output file path (.usd, .usda, .usdc)."
        },
        "actors": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Actor names to export. Empty = export level."
        },
        "export_options": {
          "type": "object",
          "properties": {
            "export_materials": { "type": "boolean", "default": true },
            "export_skeletal_meshes": { "type": "boolean", "default": true },
            "export_static_meshes": { "type": "boolean", "default": true },
            "export_landscape": { "type": "boolean", "default": false },
            "export_foliage": { "type": "boolean", "default": false }
          }
        }
      },
      "additionalProperties": false,
      "required": ["output_path"]
    }
  },

  {
    "_comment": "=== NANITE / LUMEN / VSM CONTROLS ===",
    "name": "nanite.enable_on_mesh",
    "description": "Enable or disable Nanite on a static mesh asset.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "mesh_asset": {
          "type": "string",
          "description": "Static mesh asset path."
        },
        "enable": {
          "type": "boolean",
          "default": true
        },
        "position_precision": {
          "type": "string",
          "enum": ["auto", "high", "low"],
          "default": "auto"
        },
        "keep_triangle_percent": {
          "type": "number",
          "description": "Percentage of triangles to keep as a fallback mesh (0.0-100.0).",
          "default": 100.0
        },
        "trim_relative_error": {
          "type": "number",
          "description": "Error threshold for trimming (higher = more aggressive)."
        }
      },
      "additionalProperties": false,
      "required": ["mesh_asset"]
    }
  },
  {
    "name": "nanite.audit",
    "description": "Audit Nanite usage across the projectlist enabled/disabled meshes and triangle counts.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "folder": {
          "type": "string",
          "description": "Content folder to audit. Omit for entire project."
        },
        "min_triangles": {
          "type": "integer",
          "description": "Only report meshes with at least this many triangles."
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "lumen.configure",
    "description": "Configure Lumen Global Illumination and Reflections settings.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "gi_method": {
          "type": "string",
          "enum": ["lumen", "screen_space", "none"],
          "description": "Global Illumination method."
        },
        "reflection_method": {
          "type": "string",
          "enum": ["lumen", "screen_space", "none"],
          "description": "Reflection method."
        },
        "lumen_scene_detail": {
          "type": "number",
          "description": "Lumen Scene Detail scale (higher = more detail, more cost)."
        },
        "lumen_scene_lighting_update_speed": {
          "type": "number",
          "description": "How fast GI responds to lighting changes."
        },
        "final_gather_quality": {
          "type": "number",
          "description": "Final gather ray quality."
        },
        "ray_lighting_mode": {
          "type": "string",
          "enum": ["surface_cache", "hit_lighting"],
          "description": "Lumen ray lighting mode."
        },
        "hardware_ray_tracing": {
          "type": "boolean",
          "description": "Use hardware ray tracing for Lumen."
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== EDITOR UTILITY === (API: Editor/Blutility)",
    "name": "editorutility.create_widget",
    "description": "Create an Editor Utility Widget Blueprint.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" },
        "parent_class": {
          "type": "string",
          "default": "EditorUtilityWidget"
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name"]
    }
  },
  {
    "name": "editorutility.create_blueprint",
    "description": "Create an Editor Utility Blueprint (for scripted editor actions).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" },
        "parent_class": {
          "type": "string",
          "default": "EditorUtilityObject"
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name"]
    }
  },
  {
    "name": "editorutility.run",
    "description": "Run an Editor Utility Widget or Blueprint action.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Asset path to the Editor Utility Widget/Blueprint."
        },
        "function_name": {
          "type": "string",
          "description": "Specific function to call. Omit to open widget/run default."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },

  {
    "_comment": "=== BEHAVIOR TREE ADVANCED === (API: Editor/BehaviorTreeEditor, Runtime/AIModule)",
    "name": "behaviortree.create",
    "description": "Create a new Behavior Tree asset.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name"]
    }
  },
  {
    "name": "behaviortree.add_node",
    "description": "Add a node (task, decorator, service, composite) to a Behavior Tree.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "bt_asset": { "type": "string" },
        "node_class": {
          "type": "string",
          "description": "Node class name (e.g. BTTask_MoveTo, BTDecorator_Blackboard, BTService_DefaultFocus)."
        },
        "parent_node": {
          "type": "string",
          "description": "Parent composite node name. Omit to add to root."
        },
        "child_index": {
          "type": "integer",
          "description": "Index among siblings."
        }
      },
      "additionalProperties": false,
      "required": ["bt_asset", "node_class"]
    }
  },
  {
    "name": "behaviortree.create_blackboard",
    "description": "Create a Blackboard Data asset.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "asset_name": { "type": "string" },
        "keys": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "type": {
                "type": "string",
                "enum": ["bool", "int", "float", "string", "name", "vector", "rotator", "object", "class", "enum"]
              },
              "instance_synced": { "type": "boolean", "default": false }
            },
            "required": ["name", "type"]
          }
        },
        "parent_blackboard": {
          "type": "string",
          "description": "Parent blackboard asset for inheritance."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "asset_name"]
    }
  },
  {
    "name": "behaviortree.add_blackboard_key",
    "description": "Add a key to an existing Blackboard.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blackboard_asset": { "type": "string" },
        "key_name": { "type": "string" },
        "key_type": {
          "type": "string",
          "enum": ["bool", "int", "float", "string", "name", "vector", "rotator", "object", "class", "enum"]
        },
        "instance_synced": { "type": "boolean", "default": false }
      },
      "additionalProperties": false,
      "required": ["blackboard_asset", "key_name", "key_type"]
    }
  },
  {
    "name": "behaviortree.open",
    "description": "Open a Behavior Tree or Blackboard in the editor.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "behaviortree.validate",
    "description": "Validate a Behavior Tree for errors (missing tasks, broken decorators).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "bt_asset": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["bt_asset"]
    }
  },

  {
    "_comment": "=== STATE TREE ADVANCED ===  (API: Plugins/StateTreeModule, Plugins/StateTreeEditorModule)",
    "name": "statetree.add_task",
    "description": "Add a task to a state in a StateTree.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "statetree_asset": { "type": "string" },
        "state_name": { "type": "string" },
        "task_class": {
          "type": "string",
          "description": "Task class name (e.g. FStateTreeRunParallelStateTreeTask)."
        }
      },
      "additionalProperties": false,
      "required": ["statetree_asset", "state_name", "task_class"]
    }
  },
  {
    "name": "statetree.add_condition",
    "description": "Add an enter condition to a state in a StateTree.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "statetree_asset": { "type": "string" },
        "state_name": { "type": "string" },
        "condition_class": { "type": "string" },
        "invert": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["statetree_asset", "state_name", "condition_class"]
    }
  },
  {
    "name": "statetree.set_context",
    "description": "Set the context data requirements on a StateTree asset.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "statetree_asset": { "type": "string" },
        "context_entries": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "type": { "type": "string", "description": "UStruct/UClass type path." }
            },
            "required": ["name", "type"]
          }
        }
      },
      "additionalProperties": false,
      "required": ["statetree_asset", "context_entries"]
    }
  },

  {
    "_comment": "=== PHYSICS CONTROL === (API: Plugins/PhysicsControl)",
    "name": "physicscontrol.create",
    "description": "Add a Physics Control component to an actor. Uses UPhysicsControlComponent.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "control_type": {
          "type": "string",
          "enum": ["world_space", "parent_space", "body_modifier"],
          "description": "Type of physics control."
        },
        "target_bone": {
          "type": "string",
          "description": "Bone name for skeletal mesh controls."
        },
        "parent_bone": {
          "type": "string",
          "description": "Parent bone (for parent_space controls)."
        },
        "strength": {
          "type": "number",
          "description": "Control strength.",
          "default": 1.0
        },
        "damping_ratio": {
          "type": "number",
          "default": 1.0
        }
      },
      "additionalProperties": false,
      "required": ["actor", "control_type"]
    }
  },
  {
    "name": "physicscontrol.set_target",
    "description": "Set the target transform for a physics control.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "control_name": { "type": "string" },
        "target_location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
        },
        "target_rotation": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }
        }
      },
      "additionalProperties": false,
      "required": ["actor", "control_name"]
    }
  },

  {
    "_comment": "=== GEOMETRY COLLECTION (DETAILED) ===",
    "name": "geomcollection.open",
    "description": "Open a Geometry Collection asset in the Fracture Editor.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "geomcollection.set_material",
    "description": "Set interior/exterior materials on a Geometry Collection.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string" },
        "interior_material": {
          "type": "string",
          "description": "Material for interior fracture surfaces."
        },
        "exterior_material": {
          "type": "string",
          "description": "Material for exterior surfaces."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "geomcollection.set_removal",
    "description": "Configure piece removal settings (decay, cluster crumbling, max removal mass).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor": { "type": "string" },
        "enable_removal": { "type": "boolean", "default": true },
        "removal_timer": {
          "type": "number",
          "description": "Time before pieces are removed (seconds)."
        },
        "max_removal_mass": {
          "type": "number",
          "description": "Pieces above this mass are not removed."
        },
        "enable_crumbling": {
          "type": "boolean",
          "description": "Enable cluster crumbling on removal."
        }
      },
      "additionalProperties": false,
      "required": ["actor"]
    }
  },

  {
    "_comment": "=== FETCH API DOCUMENTATION ===",
    "name": "fetch_ue_api_doc",
    "description": "Fetch Unreal Engine C++ API documentation for a specific module, class, or function from dev.epicgames.com. Reference: https://dev.epicgames.com/documentation/en-us/unreal-engine/API",
    "inputSchema": {
      "type": "object",
      "properties": {
        "category": {
          "type": "string",
          "enum": ["Runtime", "Editor", "Developer", "Plugins"],
          "description": "API category."
        },
        "module": {
          "type": "string",
          "description": "Module name (e.g. Engine, AIModule, MetasoundEngine)."
        },
        "class_name": {
          "type": "string",
          "description": "Specific class to look up (e.g. AActor, UAbilitySystemComponent)."
        },
        "function_name": {
          "type": "string",
          "description": "Specific function to look up."
        }
      },
      "additionalProperties": false,
      "required": ["category", "module"]
    }
  },
  {
    "name": "fetch_ue_api_module_list",
    "description": "List all UE C++ API modules in a given category. Reference: https://dev.epicgames.com/documentation/en-us/unreal-engine/API",
    "inputSchema": {
      "type": "object",
      "properties": {
        "category": {
          "type": "string",
          "enum": ["Runtime", "Editor", "Developer", "Plugins"],
          "description": "Category to list modules from."
        }
      },
      "additionalProperties": false,
      "required": ["category"]
    }
  },
  {
    "name": "fetch_ue_api_class_members",
    "description": "Fetch member functions, properties, and events for a UE C++ API class.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "class_path": {
          "type": "string",
          "description": "Full API path (e.g. Runtime/Engine/Classes/GameFramework/AActor)."
        },
        "include_inherited": {
          "type": "boolean",
          "description": "Include inherited members.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["class_path"]
    }
  },

  {
    "_comment": "=== BLUEPRINT GRAPH (K2Node) OPERATIONS === (API: Editor/BlueprintGraph, Editor/BlueprintEditorLibrary, Editor/Kismet)  Low-level blueprint graph manipulation using K2Node classes, FBlueprintActionDatabase, UEdGraphSchema_K2, and UBlueprintNodeSpawner. These tools give the AI deep understanding of how UE Blueprint graphs work internally."
  },
  {
    "name": "blueprintgraph.spawn_function_node",
    "description": "Spawn a UK2Node_CallFunction in a Blueprint event graph. This is the most common blueprint node  every 'call function' box in blueprints is a UK2Node_CallFunction. Specify the target function by class and function name. The node auto-creates input/output pins matching the function signature. Works with BlueprintCallable UFUNCTIONs, static library functions (UKismetMathLibrary, UGameplayStatics, etc.), and member functions.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint (e.g. /Game/Blueprints/BP_Player)."
        },
        "graph_name": {
          "type": "string",
          "description": "Name of the target graph (e.g. 'EventGraph', 'MyFunction'). Default: EventGraph.",
          "default": "EventGraph"
        },
        "target_class": {
          "type": "string",
          "description": "UClass owning the function (e.g. AActor, UKismetMathLibrary, UGameplayStatics, Self for the blueprint itself)."
        },
        "function_name": {
          "type": "string",
          "description": "Name of the UFUNCTION to call (e.g. SetActorLocation, GetWorldDeltaSeconds, PrintString)."
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "description": "Position in graph coordinates.",
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "target_class", "function_name"]
    }
  },
  {
    "name": "blueprintgraph.spawn_event_node",
    "description": "Spawn an event node in a Blueprint graph. Creates UK2Node_Event (for native events like BeginPlay, Tick, ActorBeginOverlap) or UK2Node_CustomEvent (for user-defined events). Event nodes are red title-bar nodes that serve as entry points for execution flow in Blueprint graphs.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "description": "Target graph name. Default: EventGraph.",
          "default": "EventGraph"
        },
        "event_type": {
          "type": "string",
          "enum": ["native", "custom"],
          "description": "'native' for built-in UE events (BeginPlay, Tick, etc.), 'custom' for user-defined CustomEvent."
        },
        "event_name": {
          "type": "string",
          "description": "For native: event function name (e.g. 'ReceiveBeginPlay', 'ReceiveTick', 'ReceiveActorBeginOverlap'). For custom: the custom event name."
        },
        "delegate_class": {
          "type": "string",
          "description": "For component events: the class owning the delegate (e.g. UPrimitiveComponent for OnComponentHit).",
          "default": ""
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "event_type", "event_name"]
    }
  },
  {
    "name": "blueprintgraph.spawn_variable_get",
    "description": "Spawn a UK2Node_VariableGet node (getter) in a Blueprint graph. This creates the green 'Get' node that reads a variable's value. The variable must already exist on the Blueprint. The node has one output pin of the variable's type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "variable_name": {
          "type": "string",
          "description": "Name of the Blueprint variable to get (must exist on the BP)."
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "variable_name"]
    }
  },
  {
    "name": "blueprintgraph.spawn_variable_set",
    "description": "Spawn a UK2Node_VariableSet node (setter) in a Blueprint graph. This creates the green 'Set' node that writes a variable's value. Has execution pins (flow control) plus an input pin for the new value and an output pin returning the set value.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "variable_name": {
          "type": "string",
          "description": "Name of the Blueprint variable to set (must exist on the BP)."
        },
        "default_value": {
          "type": "string",
          "description": "Default value for the input pin (as string representation).",
          "default": ""
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "variable_name"]
    }
  },
  {
    "name": "blueprintgraph.spawn_cast_node",
    "description": "Spawn a UK2Node_DynamicCast (Cast To) node in a Blueprint graph. Cast nodes convert an object reference to a specific class type, with success/fail execution pins. UK2Node_DynamicCast creates the standard 'Cast To <ClassName>' node. Used for safe type narrowing of UObject/AActor references.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "target_class": {
          "type": "string",
          "description": "Class to cast to (e.g. 'BP_Player', 'ACharacter', 'APlayerController'). Can be a C++ class name or Blueprint asset path."
        },
        "pure_cast": {
          "type": "boolean",
          "description": "If true, uses pure cast (no execution pins, returns null on failure). Default: false (impure cast with success/fail exec pins).",
          "default": false
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "target_class"]
    }
  },
  {
    "name": "blueprintgraph.spawn_flow_node",
    "description": "Spawn execution flow control nodes in a Blueprint graph. These nodes direct the flow of execution: UK2Node_IfThenElse (Branch), UK2Node_ExecutionSequence (Sequence), UK2Node_MultiGate, UK2Node_DoOnceMultiInput, UK2Node_Switch* (SwitchOnInt/String/Name/Enum), UK2Node_ForEachElementInEnum. ForEachLoop and WhileLoop are macro instances.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "flow_type": {
          "type": "string",
          "enum": ["branch", "sequence", "switch_on_int", "switch_on_string", "switch_on_name", "switch_on_enum", "multi_gate", "do_once", "do_once_multi", "for_each_loop", "for_each_enum", "while_loop", "flip_flop", "gate", "delay"],
          "description": "Type of flow control node to create."
        },
        "enum_type": {
          "type": "string",
          "description": "For switch_on_enum/for_each_enum: the UEnum path (e.g. /Script/Engine.ECollisionChannel).",
          "default": ""
        },
        "num_outputs": {
          "type": "integer",
          "description": "For sequence/multi_gate: number of output execution pins.",
          "default": 2
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "flow_type"]
    }
  },
  {
    "name": "blueprintgraph.spawn_struct_node",
    "description": "Spawn struct manipulation nodes (UK2Node_MakeStruct, UK2Node_BreakStruct, UK2Node_SetFieldsInStruct) in a Blueprint graph. MakeStruct creates a struct from individual values, BreakStruct splits a struct into individual pins, SetFieldsInStruct modifies specific fields of an existing struct instance.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "struct_type": {
          "type": "string",
          "description": "The UScriptStruct path or name (e.g. 'Vector', 'Rotator', 'Transform', 'LinearColor', 'HitResult', '/Script/Engine.HitResult')."
        },
        "node_type": {
          "type": "string",
          "enum": ["make", "break", "set_fields"],
          "description": "'make' = MakeStruct, 'break' = BreakStruct, 'set_fields' = SetFieldsInStruct."
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "struct_type", "node_type"]
    }
  },
  {
    "name": "blueprintgraph.spawn_delegate_node",
    "description": "Spawn delegate/event dispatcher nodes in a Blueprint graph. Creates UK2Node_AddDelegate (Bind), UK2Node_RemoveDelegate (Unbind), UK2Node_ClearDelegate (Unbind All), UK2Node_CallDelegate (Call/Broadcast), UK2Node_CreateDelegate (Create delegate binding), or UK2Node_AssignDelegate (Assign). These nodes manage multicast delegate (event dispatcher) bindings.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "delegate_name": {
          "type": "string",
          "description": "Name of the delegate/event dispatcher (e.g. 'OnClicked', 'OnComponentHit', 'MyCustomDispatcher')."
        },
        "delegate_operation": {
          "type": "string",
          "enum": ["bind", "unbind", "unbind_all", "call", "create", "assign"],
          "description": "Operation: bind=AddDelegate, unbind=RemoveDelegate, unbind_all=ClearDelegate, call=CallDelegate (Broadcast), create=CreateDelegate, assign=AssignDelegate."
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "delegate_name", "delegate_operation"]
    }
  },
  {
    "name": "blueprintgraph.spawn_async_node",
    "description": "Spawn a UK2Node_AsyncAction or UK2Node_BaseAsyncTask node. These create latent action nodes with multiple output execution pins (e.g., OnSuccess, OnFail, OnComplete). Common examples: AI MoveTo, PlayMontageAndWait, Delay, LoadAsset, HttpRequest, GameplayCueNotify. The proxy class drives the async pattern.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "async_class": {
          "type": "string",
          "description": "The proxy class name or function path. Examples: 'UAbilityTask_PlayMontageAndWait', 'UAbilityTask_WaitGameplayEvent', 'UBlueprintAsyncActionBase' subclass name."
        },
        "factory_function": {
          "type": "string",
          "description": "The static factory function name that creates the task (e.g. 'CreatePlayMontageAndWaitProxy', 'AI_MoveTo').",
          "default": ""
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "async_class"]
    }
  },
  {
    "name": "blueprintgraph.spawn_macro_instance",
    "description": "Spawn a UK2Node_MacroInstance node. Macros are reusable graph snippets defined in Macro Libraries or within Blueprints. Common built-in macros: ForEachLoop, ForEachLoopWithBreak, WhileLoop, IsValid, DoN, DoOnce, FlipFlop, Gate, Sequence. Macro instances expand inline during compilation (no function call overhead).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "macro_name": {
          "type": "string",
          "description": "Name of the macro (e.g. 'ForEachLoop', 'IsValid', 'DoOnce', 'Gate'). Can also be a full macro graph reference."
        },
        "macro_library": {
          "type": "string",
          "description": "Optional path to the Macro Library asset containing the macro. If empty, searches the blueprint's own macros and engine standard macros.",
          "default": ""
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "macro_name"]
    }
  },
  {
    "name": "blueprintgraph.add_comment",
    "description": "Add a comment box (UEdGraphNode_Comment) to a Blueprint graph. Comments are visual annotations that can group and document sections of the graph. They can be resized and colored. When nodes are inside a comment box, they move together.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "comment_text": {
          "type": "string",
          "description": "The comment text to display."
        },
        "position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        },
        "size": {
          "type": "object",
          "properties": { "width": { "type": "number" }, "height": { "type": "number" } },
          "description": "Size of the comment box.",
          "default": { "width": 400, "height": 200 }
        },
        "color": {
          "type": "object",
          "properties": { "r": { "type": "number" }, "g": { "type": "number" }, "b": { "type": "number" }, "a": { "type": "number" } },
          "description": "Comment bubble color (0-1 range).",
          "default": { "r": 1.0, "g": 1.0, "b": 1.0, "a": 1.0 }
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "comment_text"]
    }
  },
  {
    "name": "blueprintgraph.add_timeline",
    "description": "Add a UK2Node_Timeline node to a Blueprint graph. Timeline nodes interpolate values over time with float/vector/color/event tracks. They have Play, PlayFromStart, Stop, Reverse, SetNewTime execution inputs and Update, Finished, Direction output delegates. Timelines are fundamental for animation, material parameter sweeps, and gameplay timing.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "timeline_name": {
          "type": "string",
          "description": "Name for the new timeline (e.g. 'DoorOpenTimeline', 'FadeTimeline')."
        },
        "length": {
          "type": "number",
          "description": "Timeline duration in seconds.",
          "default": 1.0
        },
        "looping": {
          "type": "boolean",
          "default": false
        },
        "auto_play": {
          "type": "boolean",
          "default": false
        },
        "float_tracks": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string", "description": "Track name (becomes an output pin)." },
              "keys": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "time": { "type": "number" },
                    "value": { "type": "number" }
                  }
                },
                "description": "Keyframes as [{time, value}, ...]."
              }
            }
          },
          "description": "Float tracks to create.",
          "default": []
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "timeline_name"]
    }
  },
  {
    "name": "blueprintgraph.inspect_node_pins",
    "description": "Inspect all pins on a specific node in a Blueprint graph. Returns detailed pin information: name, type (FEdGraphPinType), direction (input/output), default value, whether connected, and connected node/pin names. Essential for understanding node interfaces before wiring. Each UEdGraphPin has a PinId (GUID), PinName, PinType (category + subcategory + object), Direction, and LinkedTo array.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "node_name": {
          "type": "string",
          "description": "Name or title of the node to inspect. For function calls, this is the function display name. For events, the event name."
        },
        "node_index": {
          "type": "integer",
          "description": "If multiple nodes match node_name, use this 0-based index. Default: 0.",
          "default": 0
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "node_name"]
    }
  },
  {
    "name": "blueprintgraph.wire_pins",
    "description": "Connect two pins in a Blueprint graph (create a wire). This is the core graph wiring operation  connecting output pins to input pins. The UEdGraphSchema_K2 validates type compatibility before allowing the connection. Execution pins (white arrows) connect to execution pins. Data pins connect to compatible type pins (with implicit conversions where supported).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "source_node": {
          "type": "string",
          "description": "Name/title of the source node."
        },
        "source_pin": {
          "type": "string",
          "description": "Name of the output pin on the source node (e.g. 'then', 'ReturnValue', 'Output', a variable name)."
        },
        "target_node": {
          "type": "string",
          "description": "Name/title of the target node."
        },
        "target_pin": {
          "type": "string",
          "description": "Name of the input pin on the target node (e.g. 'execute', 'NewLocation', 'Condition', 'self')."
        },
        "source_node_index": {
          "type": "integer",
          "description": "Index if multiple source nodes share same name.",
          "default": 0
        },
        "target_node_index": {
          "type": "integer",
          "description": "Index if multiple target nodes share same name.",
          "default": 0
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "source_node", "source_pin", "target_node", "target_pin"]
    }
  },
  {
    "name": "blueprintgraph.break_pin_links",
    "description": "Break all connections on a specific pin of a node in a Blueprint graph. Removes all wires attached to the specified pin, effectively disconnecting it. Uses UEdGraphSchema_K2::BreakPinLinks.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "node_name": {
          "type": "string",
          "description": "Name/title of the node."
        },
        "pin_name": {
          "type": "string",
          "description": "Name of the pin to disconnect."
        },
        "node_index": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "node_name", "pin_name"]
    }
  },
  {
    "name": "blueprintgraph.list_graph_nodes",
    "description": "List all nodes in a Blueprint graph with their K2Node class types, positions, pin counts, and connection summary. Returns the complete node inventory showing UK2Node subclass (UK2Node_CallFunction, UK2Node_Event, UK2Node_VariableGet, UK2Node_IfThenElse, etc.), display name, and pin connection state. Essential for understanding graph structure before making modifications.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "description": "Graph name. Use 'ALL' to list nodes across all graphs.",
          "default": "EventGraph"
        },
        "filter_class": {
          "type": "string",
          "description": "Optional: filter to only show nodes of this K2Node class (e.g. 'UK2Node_CallFunction', 'UK2Node_Event').",
          "default": ""
        },
        "include_pins": {
          "type": "boolean",
          "description": "Include pin details in the output.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },
  {
    "name": "blueprintgraph.get_available_functions",
    "description": "Query available Blueprint-callable functions for a given class from FBlueprintActionDatabase. Returns all functions that can be called from Blueprint graphs, including: static library functions, member functions, pure functions, latent actions, and delegate-related functions. Each entry includes the function name, owning class, parameters, return type, and Blueprint specifiers (BlueprintCallable, BlueprintPure, BlueprintAuthorityOnly, etc.).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "class_name": {
          "type": "string",
          "description": "UClass name to query functions for (e.g. 'AActor', 'UGameplayStatics', 'UKismetMathLibrary', 'ACharacter', 'APawn')."
        },
        "filter": {
          "type": "string",
          "description": "Optional substring filter for function names (e.g. 'Location', 'Overlap', 'Damage').",
          "default": ""
        },
        "include_inherited": {
          "type": "boolean",
          "description": "Include functions inherited from parent classes.",
          "default": true
        },
        "max_results": {
          "type": "integer",
          "description": "Maximum number of functions to return.",
          "default": 50
        }
      },
      "additionalProperties": false,
      "required": ["class_name"]
    }
  },
  {
    "name": "blueprintgraph.spawn_construct_object",
    "description": "Spawn object construction nodes in a Blueprint graph. UK2Node_ConstructObjectFromClass creates a new UObject instance, UK2Node_SpawnActorFromClass spawns an Actor in the world, UK2Node_AddComponent adds a component to an actor. These are the fundamental 'create object' patterns in Blueprint.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "construct_type": {
          "type": "string",
          "enum": ["construct_object", "spawn_actor", "add_component"],
          "description": "'construct_object' = ConstructObject (for UObjects), 'spawn_actor' = SpawnActorFromClass (for Actors), 'add_component' = AddComponent (for components)."
        },
        "class_to_create": {
          "type": "string",
          "description": "The class to construct/spawn (e.g. 'AStaticMeshActor', 'UBoxComponent', 'UWidgetComponent'). For add_component, this is the component class.",
          "default": ""
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "construct_type"]
    }
  },

  {
    "_comment": "=== BLUEPRINT COMPILER / VALIDATION === (API: Editor/KismetCompiler, Editor/BlueprintGraph, Editor/UnrealEd)  Tools for Blueprint compilation, node validation, and diagnostics. Compilation translates the visual graph into executable bytecode via FKismetCompilerContext."
  },
  {
    "name": "blueprintcompiler.compile",
    "description": "Compile a Blueprint with full structured error/warning reporting. Uses FKismetCompilerContext internally. Returns compilation status, list of errors with node references, warnings, and timing info. A Blueprint must be compiled after edits to make changes take effect at runtime. Compilation converts the visual K2Node graph into UFunction bytecode in the Blueprint's generated class (UBlueprintGeneratedClass).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint to compile."
        },
        "save_after_compile": {
          "type": "boolean",
          "description": "Save the asset after successful compilation.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },
  {
    "name": "blueprintcompiler.refresh_nodes",
    "description": "Refresh all nodes in a Blueprint, reconstructing their pins and updating to latest function signatures. Uses UBlueprint::BroadcastChanged and UK2Node::ReconstructNode. Essential after class/struct/function changes to update all graph nodes. Also resolves 'stale' nodes that reference outdated function signatures.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "mark_dirty": {
          "type": "boolean",
          "description": "Mark package as dirty after refresh.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },
  {
    "name": "blueprintcompiler.find_broken_links",
    "description": "Find all broken pin links and disconnected/orphaned pins in a Blueprint graph. Returns nodes with unconnected required pins, type-mismatched connections, deprecated node references, and orphaned nodes (no execution path). Uses UEdGraphSchema_K2 validation.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "description": "Specific graph to check, or 'ALL' for all graphs.",
          "default": "ALL"
        },
        "include_warnings": {
          "type": "boolean",
          "description": "Include warnings in addition to errors.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },
  {
    "name": "blueprintcompiler.check_deprecations",
    "description": "Scan a Blueprint for deprecated nodes, functions, and API usage. Finds UK2Node_DeadClass references, deprecated UFunction calls, and nodes marked with DeprecatedNode metadata. Helps identify Blueprint maintenance tasks before engine version upgrades.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint to check."
        },
        "include_engine_deprecations": {
          "type": "boolean",
          "description": "Include deprecations from engine classes (not just project code).",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },

  {
    "_comment": "=== CONTENT BROWSER OPERATIONS === (API: Editor/ContentBrowser, Editor/ContentBrowserData, Editor/UnrealEd)  Tools for Content Browser navigation, asset discovery, filtering, and collection management. The Content Browser is UE's primary asset management interface, backed by the Asset Registry (IAssetRegistry)."
  },
  {
    "name": "contentbrowser.browse",
    "description": "Navigate the Content Browser to a specific folder path and list its contents. Returns all assets and subfolders at the given path. Uses IContentBrowserSingleton and the Asset Registry for fast enumeration.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "Content path to browse (e.g. '/Game', '/Game/Blueprints', '/Engine/BasicShapes')."
        },
        "recursive": {
          "type": "boolean",
          "description": "Include assets in subfolders.",
          "default": false
        },
        "max_results": {
          "type": "integer",
          "default": 100
        }
      },
      "additionalProperties": false,
      "required": ["path"]
    }
  },
  {
    "name": "contentbrowser.filter_by_type",
    "description": "List assets filtered by class type within a content path. Uses the Asset Registry (IAssetRegistry::GetAssetsByPath + class filter) for fast type-filtered queries. Supports all UE asset types: Blueprint, StaticMesh, SkeletalMesh, Material, MaterialInstance, Texture2D, SoundWave, SoundCue, MetaSoundSource, AnimSequence, AnimMontage, AnimBlueprint, NiagaraSystem, DataTable, CurveFloat, LevelSequence, WidgetBlueprint, BehaviorTree, BlackboardData, etc.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "Content path to search (e.g. '/Game', '/Game/Characters')."
        },
        "class_name": {
          "type": "string",
          "description": "UClass name to filter by (e.g. 'Blueprint', 'StaticMesh', 'Material', 'DataTable', 'WidgetBlueprint')."
        },
        "recursive": {
          "type": "boolean",
          "default": true
        },
        "name_filter": {
          "type": "string",
          "description": "Optional substring filter on asset names.",
          "default": ""
        },
        "max_results": {
          "type": "integer",
          "default": 100
        }
      },
      "additionalProperties": false,
      "required": ["path", "class_name"]
    }
  },
  {
    "name": "contentbrowser.get_asset_metadata",
    "description": "Get detailed metadata for a specific asset. Returns: class type, disk size, memory size, dependencies, referencers, package flags, asset tags/metadata, is dirty, source control status. Uses FAssetData and FAssetRegistryModule for comprehensive asset introspection.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Full asset path (e.g. /Game/Blueprints/BP_Player)."
        },
        "include_dependencies": {
          "type": "boolean",
          "description": "Include dependency chain.",
          "default": true
        },
        "include_referencers": {
          "type": "boolean",
          "description": "Include assets that reference this one.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "contentbrowser.create_collection",
    "description": "Create or manage asset collections (formerly known as 'favorites'). Collections are named groups of asset references stored per-user or shared. Types: Local (per-user), Shared (team-visible), Private. Uses ICollectionManager.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": {
          "type": "string",
          "enum": ["create", "delete", "add_asset", "remove_asset", "list", "list_assets"],
          "description": "Operation to perform."
        },
        "collection_name": {
          "type": "string",
          "description": "Name of the collection.",
          "default": ""
        },
        "collection_type": {
          "type": "string",
          "enum": ["local", "shared", "private"],
          "default": "local"
        },
        "asset_path": {
          "type": "string",
          "description": "Asset path for add_asset/remove_asset operations.",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },
  {
    "name": "contentbrowser.sync_to_asset",
    "description": "Sync the Content Browser to show a specific asset or folder, making it visible and selected. Equivalent to right-clicking an asset and choosing 'Browse to Asset'. Uses IContentBrowserSingleton::SyncBrowserToAssets.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Asset or folder path to navigate to."
        },
        "focus_content_browser": {
          "type": "boolean",
          "description": "Bring Content Browser tab to front.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },

  {
    "_comment": "=== EDITOR MODE / GLOBAL STATE === (API: Editor/UnrealEd, Editor/LevelEditor, Runtime/Engine)  Tools for controlling the editor's global state: active editing mode, viewport configuration, grid snapping, and bookmarks. Uses GEditor, FEditorModeManager, FLevelEditorViewportClient."
  },
  {
    "name": "editormode.get_state",
    "description": "Get the current state of the Unreal Editor. Returns: active editor mode (select/translate/rotate/scale/placement/landscape/foliage/mesh_paint), selected actors/assets count, viewport info (perspective/ortho, view mode, real-time enabled), PIE status, grid snap settings, and loaded level name. Comprehensive editor state snapshot for AI decision-making.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "include_selection": {
          "type": "boolean",
          "description": "Include details about currently selected actors/assets.",
          "default": true
        },
        "include_viewport": {
          "type": "boolean",
          "description": "Include viewport configuration details.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "editormode.switch_mode",
    "description": "Switch the active editor interaction mode. Modes determine what tools are available and how mouse/keyboard input is interpreted. Uses FEditorModeManager::ActivateMode. Common modes: EM_Default (Select), EM_Placement, EM_Landscape, EM_Foliage, EM_MeshPaint, EM_Geometry.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "enum": ["select", "translate", "rotate", "scale", "placement", "landscape", "foliage", "mesh_paint", "geometry", "fracture"],
          "description": "Editor mode to activate."
        }
      },
      "additionalProperties": false,
      "required": ["mode"]
    }
  },
  {
    "name": "editormode.configure_grid",
    "description": "Configure editor grid snapping settings for translation, rotation, and scale. Controls how actors snap to grid positions during transform operations. Uses ULevelEditorViewportSettings.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "grid_enabled": {
          "type": "boolean",
          "description": "Enable/disable position grid snapping."
        },
        "grid_size": {
          "type": "number",
          "description": "Grid size in Unreal Units (e.g. 10, 25, 50, 100).",
          "default": 10
        },
        "rotation_snap_enabled": {
          "type": "boolean",
          "description": "Enable/disable rotation snapping."
        },
        "rotation_snap_degrees": {
          "type": "number",
          "description": "Rotation snap increment in degrees (e.g. 5, 10, 15, 45, 90).",
          "default": 10
        },
        "scale_snap_enabled": {
          "type": "boolean",
          "description": "Enable/disable scale snapping."
        },
        "scale_snap_value": {
          "type": "number",
          "description": "Scale snap increment (e.g. 0.1, 0.25, 0.5).",
          "default": 0.25
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "editormode.viewport_config",
    "description": "Configure the active Level Editor viewport. Set view mode (lit, unlit, wireframe, detail lighting, etc.), show flags (show/hide specific element categories), real-time rendering, and exposure settings. Uses FLevelEditorViewportClient and FEngineShowFlags.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "view_mode": {
          "type": "string",
          "enum": ["lit", "unlit", "wireframe", "detail_lighting", "lighting_only", "light_complexity", "shader_complexity", "stationary_light_overlap", "lightmap_density", "reflections", "buffer_visualization", "collision", "path_tracing"],
          "description": "Viewport rendering view mode."
        },
        "realtime": {
          "type": "boolean",
          "description": "Enable real-time viewport updates."
        },
        "show_flags": {
          "type": "object",
          "description": "Show/hide element categories. Keys are flag names (e.g. 'StaticMeshes', 'SkeletalMeshes', 'Fog', 'Particles', 'PostProcessing', 'Grid', 'BSP', 'Collision', 'Navigation'), values are booleans.",
          "additionalProperties": { "type": "boolean" }
        },
        "exposure": {
          "type": "object",
          "properties": {
            "auto": { "type": "boolean" },
            "bias": { "type": "number" },
            "min": { "type": "number" },
            "max": { "type": "number" }
          }
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "editormode.manage_bookmarks",
    "description": "Create, list, or jump to viewport bookmarks. Bookmarks save camera position/rotation for quick navigation to key locations in the level. Uses FBookmarkBaseJumpToSettings and AWorldSettings bookmark storage. Bookmarks are accessed via Ctrl+0-9 to jump and Ctrl+Shift+0-9 to set.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": {
          "type": "string",
          "enum": ["set", "jump", "list", "clear"],
          "description": "Operation: set=save current view, jump=go to bookmark, list=list all, clear=remove bookmark."
        },
        "bookmark_index": {
          "type": "integer",
          "description": "Bookmark slot index (0-9).",
          "default": 0
        },
        "bookmark_name": {
          "type": "string",
          "description": "Optional descriptive name for the bookmark.",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },

  {
    "_comment": "=== CLASS REFLECTION / UE TYPE SYSTEM === (API: Runtime/CoreUObject, Runtime/Engine/Classes/Engine/Blueprint)  Tools for UClass/UStruct/UFunction/UProperty reflection. These give the AI deep understanding of UE's type system, inheritance hierarchies, and available callable APIs. Uses UClass::GetDefaultObject, UClass::FuncMap, FProperty iteration, and class hierarchy traversal."
  },
  {
    "name": "classreflection.get_class_hierarchy",
    "description": "Get the complete inheritance chain for any UClass. Returns the class and all its parent classes up to UObject, showing the full inheritance hierarchy. Also returns interfaces implemented by the class. This is how UE's type system works: all classes inherit from UObject, with AActor and UActorComponent being the two main branches. Understanding hierarchy is critical for knowing which functions/properties are available.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "class_name": {
          "type": "string",
          "description": "Name of the class (e.g. 'ACharacter', 'UStaticMeshComponent', 'UGameplayAbility', 'APawn'). Can also be a Blueprint asset path."
        },
        "include_interfaces": {
          "type": "boolean",
          "description": "Include implemented interfaces.",
          "default": true
        },
        "include_cdo_properties": {
          "type": "boolean",
          "description": "Include Class Default Object (CDO) property values.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["class_name"]
    }
  },
  {
    "name": "classreflection.list_class_functions",
    "description": "List all UFunctions on a UClass, with filtering by specifiers. Returns function name, parameter list, return type, and Blueprint specifiers (BlueprintCallable, BlueprintPure, BlueprintImplementableEvent, BlueprintNativeEvent, BlueprintAuthorityOnly, Exec, etc.). This tells the AI exactly what functions can be called from Blueprint graphs on this class.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "class_name": {
          "type": "string",
          "description": "UClass name (e.g. 'AActor', 'UPrimitiveComponent', 'UGameplayStatics')."
        },
        "filter": {
          "type": "string",
          "description": "Substring filter on function names.",
          "default": ""
        },
        "specifier_filter": {
          "type": "string",
          "enum": ["all", "blueprint_callable", "blueprint_pure", "blueprint_event", "native_event", "exec", "latent", "cosmetic"],
          "description": "Filter functions by specifier type.",
          "default": "all"
        },
        "include_inherited": {
          "type": "boolean",
          "default": true
        },
        "max_results": {
          "type": "integer",
          "default": 50
        }
      },
      "additionalProperties": false,
      "required": ["class_name"]
    }
  },
  {
    "name": "classreflection.list_class_properties",
    "description": "List all FProperty (UProperty) fields on a UClass with types, flags, metadata, and default values. Returns property name, C++ type (float, int32, FVector, UObject*, TArray, TMap, etc.), Blueprint type (visible/editable/read-only), replication flags, category, tooltip, and EditCondition. This is the AI's window into UE's property system  every class member variable exposed to the editor/Blueprint system.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "class_name": {
          "type": "string",
          "description": "UClass name (e.g. 'AActor', 'ACharacter', 'UStaticMeshComponent')."
        },
        "filter": {
          "type": "string",
          "description": "Substring filter on property names.",
          "default": ""
        },
        "flag_filter": {
          "type": "string",
          "enum": ["all", "blueprint_visible", "editable", "replicated", "config", "transient"],
          "description": "Filter properties by flag type.",
          "default": "all"
        },
        "include_inherited": {
          "type": "boolean",
          "default": false
        },
        "max_results": {
          "type": "integer",
          "default": 50
        }
      },
      "additionalProperties": false,
      "required": ["class_name"]
    }
  },
  {
    "name": "classreflection.find_classes_by_parent",
    "description": "Find all UClasses that inherit from a given parent class. Returns the full list of subclasses (direct and indirect). Essential for discovering available types: e.g., all Actor types (subclasses of AActor), all Component types (UActorComponent), all Widget types (UWidget), all assets of a type (UPrimaryDataAsset). Uses GetDerivedClasses.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "parent_class": {
          "type": "string",
          "description": "Parent UClass name to find subclasses of (e.g. 'AActor', 'UActorComponent', 'UWidget', 'UGameplayAbility', 'UAnimInstance')."
        },
        "direct_only": {
          "type": "boolean",
          "description": "Only return direct subclasses (not grandchildren etc.).",
          "default": false
        },
        "name_filter": {
          "type": "string",
          "description": "Optional substring filter on class names.",
          "default": ""
        },
        "max_results": {
          "type": "integer",
          "default": 100
        }
      },
      "additionalProperties": false,
      "required": ["parent_class"]
    }
  },
  {
    "name": "classreflection.get_function_signature",
    "description": "Get the complete function signature for a specific UFunction on a UClass. Returns: all parameters with names, types (C++ FProperty types mapped to Blueprint pin types), default values, output parameters, return value, function flags (Static, Const, BlueprintCallable, BlueprintPure, BlueprintImplementableEvent, Latent, WorldContext, etc.), and metadata (Category, Keywords, ToolTip, DeprecatedFunction, etc.). This is the definitive function introspection tool.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "class_name": {
          "type": "string",
          "description": "UClass owning the function."
        },
        "function_name": {
          "type": "string",
          "description": "Name of the UFunction."
        }
      },
      "additionalProperties": false,
      "required": ["class_name", "function_name"]
    }
  },

  {
    "_comment": "=== ANIM GRAPH / ANIMATION BLUEPRINT === (API: Editor/AnimGraph, Editor/AnimationBlueprintEditor, Editor/AnimationBlueprintLibrary, Editor/AnimationSettings)  Animation Blueprint graph editing: state machines, states, transitions, blend nodes, animation layers, anim slots. Uses UAnimGraphNode_*, UAnimStateNode, UAnimStateTransitionNode, FAnimationBlueprintEditorModule, UAnimationBlueprintLibrary."
  },
  {
    "name": "animgraph.add_state_machine",
    "description": "Add a new state machine sub-graph to an Animation Blueprint. State machines in AnimBP are UAnimGraphNode_StateMachineBase / UAnimBlueprintGeneratedClass nodes that contain states (UAnimStateNode) and transitions (UAnimStateTransitionNode). The state machine appears as a single node in the parent AnimGraph and can be expanded to edit its internal state graph. Common pattern: Locomotion SM, Combat SM, etc.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Animation Blueprint (e.g. /Game/Characters/ABP_Player)."
        },
        "state_machine_name": {
          "type": "string",
          "description": "Name for the new state machine (e.g. 'Locomotion', 'Combat', 'UpperBody')."
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path", "state_machine_name"]
    }
  },
  {
    "name": "animgraph.add_state",
    "description": "Add a state (UAnimStateNode) to an existing state machine in an Animation Blueprint. States contain animation pose logic (play animations, blend spaces, etc.). Each state has an output pose pin. Special states: Entry (always exists), Conduit (UAnimStateConduitNode) for pass-through logic.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Animation Blueprint."
        },
        "state_machine_name": {
          "type": "string",
          "description": "Name of the state machine to add the state to."
        },
        "state_name": {
          "type": "string",
          "description": "Name for the new state (e.g. 'Idle', 'Walk', 'Run', 'Jump', 'Fall')."
        },
        "is_conduit": {
          "type": "boolean",
          "description": "If true, creates a conduit node instead of a regular state.",
          "default": false
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path", "state_machine_name", "state_name"]
    }
  },
  {
    "name": "animgraph.add_transition",
    "description": "Add a transition rule (UAnimStateTransitionNode) between two states in a state machine. Transition rules define conditions for moving between states. Each transition has a boolean result pin that determines if the transition can fire. Properties include blend duration, blend mode (standard/inertialization), blend profile, priority order, and bidirectional settings.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Animation Blueprint."
        },
        "state_machine_name": {
          "type": "string",
          "description": "State machine name."
        },
        "from_state": {
          "type": "string",
          "description": "Source state name (e.g. 'Idle')."
        },
        "to_state": {
          "type": "string",
          "description": "Destination state name (e.g. 'Walk')."
        },
        "blend_duration": {
          "type": "number",
          "description": "Crossfade blend duration in seconds.",
          "default": 0.2
        },
        "blend_mode": {
          "type": "string",
          "enum": ["standard", "inertialization", "custom"],
          "default": "standard"
        },
        "bidirectional": {
          "type": "boolean",
          "description": "Create transition in both directions.",
          "default": false
        },
        "priority_order": {
          "type": "integer",
          "description": "Priority when multiple transitions are valid (lower = higher priority).",
          "default": 1
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path", "state_machine_name", "from_state", "to_state"]
    }
  },
  {
    "name": "animgraph.add_blend_node",
    "description": "Add a blend node to an Animation Blueprint graph. Blend nodes combine multiple animation poses: UAnimGraphNode_LayeredBoneBlend (Layered Blend Per Bone), UAnimGraphNode_BlendListByBool, UAnimGraphNode_BlendListByInt, UAnimGraphNode_BlendListByEnum, UAnimGraphNode_TwoWayBlend, UAnimGraphNode_BlendSpacePlayer, UAnimGraphNode_AimOffsetLookAt. These nodes are fundamental to animation layering and blending logic.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Animation Blueprint."
        },
        "graph_name": {
          "type": "string",
          "description": "Target graph (e.g. 'AnimGraph', state name, function name).",
          "default": "AnimGraph"
        },
        "blend_type": {
          "type": "string",
          "enum": ["layered_bone_blend", "blend_by_bool", "blend_by_int", "blend_by_enum", "two_way_blend", "blend_space_player", "aim_offset", "additive", "apply_additive"],
          "description": "Type of blend node to create."
        },
        "num_inputs": {
          "type": "integer",
          "description": "Number of blend input poses (for blend_by_int, layered).",
          "default": 2
        },
        "blend_space_path": {
          "type": "string",
          "description": "For blend_space_player/aim_offset: path to the BlendSpace asset.",
          "default": ""
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path", "blend_type"]
    }
  },
  {
    "name": "animgraph.add_anim_layer",
    "description": "Add a linked animation layer or animation layer interface to an AnimBP. Animation Layers (UAnimGraphNode_LinkedAnimLayer) allow modular AnimBP composition  a child AnimBP can implement layers defined by a parent interface. This is UE5's recommended approach for scalable character animation. Uses IAnimLayerInterface and UAnimLayerInterfaceLibrary.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Animation Blueprint."
        },
        "layer_name": {
          "type": "string",
          "description": "Name of the animation layer (e.g. 'FullBodyLayer', 'UpperBodyLayer')."
        },
        "interface_path": {
          "type": "string",
          "description": "Path to the Animation Layer Interface asset. If empty, creates an inline layer.",
          "default": ""
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path", "layer_name"]
    }
  },
  {
    "name": "animgraph.list_states",
    "description": "List all states and transitions in a state machine within an Animation Blueprint. Returns state names, conduit flags, transition rules with source/destination/blend settings, and the overall state machine topology. Essential for understanding AnimBP structure before modifications.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Animation Blueprint."
        },
        "state_machine_name": {
          "type": "string",
          "description": "Name of the state machine to inspect."
        },
        "include_transitions": {
          "type": "boolean",
          "description": "Include transition rules in output.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path", "state_machine_name"]
    }
  },
  {
    "name": "animgraph.add_slot_node",
    "description": "Add an Animation Slot node (UAnimGraphNode_Slot) to an AnimBP graph. Slot nodes allow Montages to override the base animation pose on specific bones. Named slots (e.g. 'DefaultSlot', 'UpperBody', 'FullBody') are used by UAnimMontage to layer montage playback on top of state machine output. Fundamental for action/ability animation playback.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Animation Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "AnimGraph"
        },
        "slot_name": {
          "type": "string",
          "description": "Name of the slot (e.g. 'DefaultSlot', 'UpperBody'). Must match SlotName used in Montages.",
          "default": "DefaultSlot"
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path"]
    }
  },
  {
    "name": "animgraph.add_cached_pose",
    "description": "Add Save Cached Pose / Use Cached Pose nodes to an AnimBP graph. UAnimGraphNode_SaveCachedPose saves a pose result that can be reused multiple times via UAnimGraphNode_UseCachedPose, avoiding redundant evaluation. Critical for performance when the same pose feeds multiple blend branches.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Animation Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "AnimGraph"
        },
        "node_type": {
          "type": "string",
          "enum": ["save_cached_pose", "use_cached_pose"],
          "description": "'save_cached_pose' creates a SaveCachedPose node, 'use_cached_pose' creates a UseCachedPose reference."
        },
        "cache_name": {
          "type": "string",
          "description": "Name of the cached pose (e.g. 'BasePose', 'UpperBodyPose'). UseCachedPose must match a SaveCachedPose name."
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path", "node_type", "cache_name"]
    }
  },

  {
    "_comment": "=== ANIMATION MODIFIERS === (API: Editor/AnimationModifiers)  Post-process modifiers applied to AnimSequences. UAnimationModifier subclasses (OnApply/OnRevert) operate on animation data: add notifies, adjust curves, generate root motion, strip bones, etc."
  },
  {
    "name": "animmodifier.apply",
    "description": "Apply an animation modifier to an AnimSequence. Animation Modifiers (UAnimationModifier subclasses) are Blueprint/C++ classes that modify animation data when applied. Common modifiers: add notify tracks, generate curve data, adjust root motion, copy/mirror bones. Uses UAnimationBlueprintLibrary::ApplyAnimationModifier.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_sequence_path": {
          "type": "string",
          "description": "Asset path of the AnimSequence."
        },
        "modifier_class": {
          "type": "string",
          "description": "Class name or asset path of the UAnimationModifier to apply."
        }
      },
      "additionalProperties": false,
      "required": ["anim_sequence_path", "modifier_class"]
    }
  },
  {
    "name": "animmodifier.list_available",
    "description": "List all available animation modifier classes in the project. Returns both C++ and Blueprint-based UAnimationModifier subclasses. These can be applied to AnimSequences to post-process animation data.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "filter": {
          "type": "string",
          "description": "Optional name filter.",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "animmodifier.add_to_stack",
    "description": "Add an animation modifier to an AnimSequence's modifier stack. Modifiers in the stack are applied in order. The stack persists on the asset and can be re-applied after source animation changes. Uses UAnimationBlueprintLibrary.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_sequence_path": {
          "type": "string",
          "description": "Asset path of the AnimSequence."
        },
        "modifier_class": {
          "type": "string",
          "description": "Modifier class to add to the stack."
        },
        "position": {
          "type": "integer",
          "description": "Stack position (0-based). -1 for end.",
          "default": -1
        }
      },
      "additionalProperties": false,
      "required": ["anim_sequence_path", "modifier_class"]
    }
  },
  {
    "name": "animmodifier.remove_from_stack",
    "description": "Remove an animation modifier from an AnimSequence's modifier stack by index or class name.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_sequence_path": {
          "type": "string",
          "description": "Asset path of the AnimSequence."
        },
        "modifier_index": {
          "type": "integer",
          "description": "Stack index to remove. Use -1 with modifier_class to remove by class.",
          "default": -1
        },
        "modifier_class": {
          "type": "string",
          "description": "Class name to remove (if modifier_index is -1).",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": ["anim_sequence_path"]
    }
  },

  {
    "_comment": "=== BLUTILITY / EDITOR UTILITY === (API: Editor/Blutility)  Editor Utility Widgets (UEditorUtilityWidget) and Blueprints (UEditorUtilityBlueprint / UEditorUtilityObject). Blutilities extend the editor with custom tool UIs and automation scripts. Run via right-click 'Run Editor Utility Widget' or through UEditorUtilitySubsystem."
  },
  {
    "name": "blutility.run_utility_widget",
    "description": "Run (spawn) an Editor Utility Widget. EUW widgets are UMG widgets that run in the editor as floating tool windows. They can contain buttons, sliders, lists, and custom logic for editor automation. Uses UEditorUtilitySubsystem::SpawnAndRegisterTab.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "widget_path": {
          "type": "string",
          "description": "Asset path of the Editor Utility Widget Blueprint (e.g. /Game/EditorTools/EUW_LevelTools)."
        }
      },
      "additionalProperties": false,
      "required": ["widget_path"]
    }
  },
  {
    "name": "blutility.create_utility_blueprint",
    "description": "Create a new Editor Utility Blueprint (UEditorUtilityBlueprint). These are Blueprints that derive from UEditorUtilityObject or AActor and can run editor-only logic. Functions marked 'Call In Editor' appear as buttons in the Details panel.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Path for the new asset (e.g. /Game/EditorTools/EUB_BatchRename)."
        },
        "parent_class": {
          "type": "string",
          "description": "Parent class: 'EditorUtilityObject', 'ActorActionUtility', 'AssetActionUtility', 'Actor'.",
          "default": "EditorUtilityObject"
        }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "blutility.create_utility_widget",
    "description": "Create a new Editor Utility Widget Blueprint (UEditorUtilityWidgetBlueprint). EUW widgets appear as dockable editor tabs. They are WidgetBlueprints with an EditorUtility parent, giving them access to editor subsystems and utility functions.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Path for the new widget (e.g. /Game/EditorTools/EUW_MyTool)."
        },
        "initial_widgets": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Initial child widget types to add (e.g. ['Button', 'TextBlock', 'VerticalBox']).",
          "default": []
        }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "blutility.list_utilities",
    "description": "List all Editor Utility Widgets and Editor Utility Blueprints in the project. Returns asset paths, parent classes, and whether they have 'Call In Editor' functions.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "Content path to search.",
          "default": "/Game"
        },
        "type_filter": {
          "type": "string",
          "enum": ["all", "widget", "blueprint"],
          "default": "all"
        },
        "recursive": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "blutility.run_function",
    "description": "Run a specific function on an Editor Utility Blueprint/Object. Executes a Blueprint function marked as 'Call In Editor' or any BlueprintCallable function on the utility object. Uses UEditorUtilitySubsystem::TryRun.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Editor Utility Blueprint."
        },
        "function_name": {
          "type": "string",
          "description": "Name of the function to execute."
        },
        "parameters": {
          "type": "object",
          "description": "Key-value parameters to pass to the function.",
          "additionalProperties": true,
          "default": {}
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "function_name"]
    }
  },

  {
    "_comment": "=== DATA TABLE EDITOR === (API: Editor/DataTableEditor)  DataTable editing operations: row CRUD, field editing, import/export, validation. UDataTable stores structured data rows keyed by FName, backed by a UScriptStruct row type."
  },
  {
    "name": "datatable.create",
    "description": "Create a new DataTable asset with a specified row struct. DataTables (UDataTable) are keyed data containers where each row is an instance of a UScriptStruct (FTableRowBase subclass). Used extensively for game data: items, abilities, levels, dialogue, loot tables, etc.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Path for the new DataTable (e.g. /Game/Data/DT_Items)."
        },
        "row_struct": {
          "type": "string",
          "description": "Row struct path or name (e.g. '/Script/MyProject.FItemData', 'FItemData', or a UserDefinedStruct path)."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "row_struct"]
    }
  },
  {
    "name": "datatable.add_row",
    "description": "Add a new row to an existing DataTable. Each row has a unique FName key and struct field values. The fields must match the DataTable's row struct definition.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "datatable_path": {
          "type": "string",
          "description": "Asset path of the DataTable."
        },
        "row_name": {
          "type": "string",
          "description": "Unique row key name (e.g. 'Sword_01', 'Level_Desert', 'Ability_Fireball')."
        },
        "row_values": {
          "type": "object",
          "description": "Key-value pairs for row fields (field names as keys). Values should match the struct field types.",
          "additionalProperties": true
        }
      },
      "additionalProperties": false,
      "required": ["datatable_path", "row_name", "row_values"]
    }
  },
  {
    "name": "datatable.edit_row",
    "description": "Edit specific fields of an existing row in a DataTable. Only specified fields are modified; unmentioned fields retain their current values.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "datatable_path": {
          "type": "string",
          "description": "Asset path of the DataTable."
        },
        "row_name": {
          "type": "string",
          "description": "Row key to edit."
        },
        "field_updates": {
          "type": "object",
          "description": "Fields to update (field name  new value).",
          "additionalProperties": true
        }
      },
      "additionalProperties": false,
      "required": ["datatable_path", "row_name", "field_updates"]
    }
  },
  {
    "name": "datatable.remove_row",
    "description": "Remove a row from a DataTable by its row name key.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "datatable_path": {
          "type": "string",
          "description": "Asset path of the DataTable."
        },
        "row_name": {
          "type": "string",
          "description": "Row key to remove."
        }
      },
      "additionalProperties": false,
      "required": ["datatable_path", "row_name"]
    }
  },
  {
    "name": "datatable.get_row",
    "description": "Get a specific row's data from a DataTable, returning all field names and values. Also returns the row struct type information.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "datatable_path": {
          "type": "string",
          "description": "Asset path of the DataTable."
        },
        "row_name": {
          "type": "string",
          "description": "Row key to retrieve."
        }
      },
      "additionalProperties": false,
      "required": ["datatable_path", "row_name"]
    }
  },
  {
    "name": "datatable.query",
    "description": "Query/search rows in a DataTable by field values or patterns. Returns matching rows with their full data. Supports substring matching on string fields and numeric range comparisons.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "datatable_path": {
          "type": "string",
          "description": "Asset path of the DataTable."
        },
        "field_name": {
          "type": "string",
          "description": "Field name to search in."
        },
        "search_value": {
          "type": "string",
          "description": "Value to search for (substring match for strings, exact match for numbers)."
        },
        "max_results": {
          "type": "integer",
          "default": 50
        }
      },
      "additionalProperties": false,
      "required": ["datatable_path", "field_name", "search_value"]
    }
  },

  {
    "_comment": "=== DATA LAYER EDITOR === (API: Editor/DataLayerEditor)  World Partition Data Layers: create, assign actors, manage runtime state. UDataLayerInstance / UDataLayerAsset organize actors into loadable groups for World Partition streaming."
  },
  {
    "name": "datalayer.create",
    "description": "Create a new Data Layer for World Partition. Data Layers group actors for streaming control  actors assigned to a data layer load/unload together. Supports runtime layers (streamed in/out during gameplay) and editor-only layers (organizational). Uses UDataLayerEditorSubsystem.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "layer_name": {
          "type": "string",
          "description": "Name for the data layer (e.g. 'DL_Gameplay_Town', 'DL_Cinematic_Intro')."
        },
        "is_runtime": {
          "type": "boolean",
          "description": "If true, layer participates in runtime streaming. If false, editor-only organizational layer.",
          "default": true
        },
        "initial_state": {
          "type": "string",
          "enum": ["activated", "loaded", "unloaded"],
          "description": "Initial runtime state: 'activated' (loaded+visible), 'loaded' (loaded but hidden), 'unloaded'.",
          "default": "activated"
        },
        "parent_layer": {
          "type": "string",
          "description": "Optional parent data layer name for hierarchy.",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": ["layer_name"]
    }
  },
  {
    "name": "datalayer.assign_actors",
    "description": "Assign actors to a Data Layer. Assigned actors will stream in/out when the layer's state changes. An actor can belong to multiple data layers  it loads when ANY assigned layer is loaded.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "layer_name": {
          "type": "string",
          "description": "Data layer to assign actors to."
        },
        "actor_labels": {
          "type": "array",
          "items": { "type": "string" },
          "description": "List of actor labels (display names in outliner) to assign."
        }
      },
      "additionalProperties": false,
      "required": ["layer_name", "actor_labels"]
    }
  },
  {
    "name": "datalayer.set_runtime_state",
    "description": "Set the initial runtime state of a Data Layer. Controls whether actors in this layer start as Activated (loaded+visible), Loaded (loaded but hidden), or Unloaded when the game starts or the region is streamed in.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "layer_name": {
          "type": "string",
          "description": "Data layer name."
        },
        "state": {
          "type": "string",
          "enum": ["activated", "loaded", "unloaded"],
          "description": "Runtime state to set."
        }
      },
      "additionalProperties": false,
      "required": ["layer_name", "state"]
    }
  },
  {
    "name": "datalayer.list",
    "description": "List all Data Layers in the current level/world. Returns layer names, types (runtime/editor), initial states, actor counts, parent-child hierarchy, and whether they are locked.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "include_actor_counts": {
          "type": "boolean",
          "description": "Include count of actors assigned to each layer.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== KISMET / BLUEPRINT EDITOR === (API: Editor/Kismet, Editor/KismetCompiler, Editor/KismetWidgets)  Blueprint editor operations beyond node-level graph editing: function/macro graph management, local variable CRUD, blueprint-level operations, search & replace, reparenting. SKismetInspector, FBlueprintEditor, FKismetCompilerContext."
  },
  {
    "name": "kismet.add_function_graph",
    "description": "Add a new function graph to a Blueprint. Creates a new UEdGraph with function entry/return nodes and adds it to the Blueprint's FunctionGraphs array. Functions have typed input/output parameters and can be marked Pure, Const, Static, BlueprintCallable. Uses FBlueprintEditorUtils::AddFunctionGraph.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "function_name": {
          "type": "string",
          "description": "Name for the new function (e.g. 'CalculateDamage', 'GetPlayerHealth')."
        },
        "access": {
          "type": "string",
          "enum": ["public", "protected", "private"],
          "default": "public"
        },
        "is_pure": {
          "type": "boolean",
          "description": "Pure functions have no execution pins (no side effects).",
          "default": false
        },
        "is_const": {
          "type": "boolean",
          "description": "Const functions don't modify the owning object.",
          "default": false
        },
        "inputs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "type": { "type": "string", "description": "Pin type: bool, int, float, string, vector, rotator, transform, object, class, name, text, enum, struct, array, set, map, or a class/struct path." }
            }
          },
          "description": "Function input parameters.",
          "default": []
        },
        "outputs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "type": { "type": "string" }
            }
          },
          "description": "Function output/return parameters.",
          "default": []
        },
        "category": {
          "type": "string",
          "description": "Category for organizing in the My Blueprint panel.",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "function_name"]
    }
  },
  {
    "name": "kismet.add_macro_graph",
    "description": "Add a new macro graph to a Blueprint. Macros are reusable node groups that expand inline during compilation (no function call overhead). Macros can have multiple exec output pins (unlike functions). They exist only in the Blueprint editor, not at runtime. Uses FBlueprintEditorUtils::AddMacroGraph.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "macro_name": {
          "type": "string",
          "description": "Name for the new macro."
        },
        "inputs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "type": { "type": "string" }
            }
          },
          "default": []
        },
        "outputs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "type": { "type": "string" }
            }
          },
          "default": []
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "macro_name"]
    }
  },
  {
    "name": "kismet.add_local_variable",
    "description": "Add a local variable to a Blueprint function graph. Local variables are scoped to a single function and are not visible in other functions or the event graph. Uses FBlueprintEditorUtils::AddLocalVariable.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "function_name": {
          "type": "string",
          "description": "Function graph to add the local variable to."
        },
        "variable_name": {
          "type": "string",
          "description": "Name for the local variable."
        },
        "variable_type": {
          "type": "string",
          "description": "Type: bool, int, float, string, vector, rotator, transform, name, text, or class/struct path."
        },
        "default_value": {
          "type": "string",
          "description": "Default value as string representation.",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "function_name", "variable_name", "variable_type"]
    }
  },
  {
    "name": "kismet.search_nodes",
    "description": "Search for nodes in a Blueprint by name, type, or content. Uses FBlueprintSearchUtils to find nodes matching criteria across all graphs. Returns node names, types, graph locations, and pin connections. Similar to the Blueprint editor's Find Results panel.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "search_term": {
          "type": "string",
          "description": "Search term (node name, function name, variable name, comment text)."
        },
        "search_type": {
          "type": "string",
          "enum": ["name", "type", "comment", "all"],
          "description": "'name' searches node titles, 'type' searches K2Node class names, 'comment' searches comment nodes, 'all' searches everything.",
          "default": "all"
        },
        "graph_name": {
          "type": "string",
          "description": "Limit search to a specific graph. 'ALL' for all graphs.",
          "default": "ALL"
        },
        "max_results": {
          "type": "integer",
          "default": 50
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "search_term"]
    }
  },
  {
    "name": "kismet.reparent_blueprint",
    "description": "Change the parent class of a Blueprint. Updates the Blueprint's ParentClass, which changes all inherited functions, properties, and components. Uses FBlueprintEditorUtils::ReparentBlueprint. WARNING: This can break existing nodes that reference parent class functions/properties. Always compile and check for errors after reparenting.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "new_parent_class": {
          "type": "string",
          "description": "New parent class name or path (e.g. 'ACharacter', 'APawn', '/Game/Framework/BP_BaseCharacter')."
        },
        "compile_after": {
          "type": "boolean",
          "description": "Compile the Blueprint after reparenting to check for errors.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "new_parent_class"]
    }
  },
  {
    "name": "kismet.list_graphs",
    "description": "List all graphs in a Blueprint: EventGraph(s), Function graphs, Macro graphs, Delegate graphs, and Animation graphs (for AnimBPs). Returns graph names, types, node counts, and entry points. Essential for understanding Blueprint structure.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "include_node_counts": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },

  {
    "_comment": "=== UMG EDITOR / WIDGET BLUEPRINT === (API: Editor/UMGEditor)  Widget Blueprint (UWidgetBlueprint) editor operations: widget hierarchy management, slot configuration, property bindings, widget animations. Uses UWidgetBlueprintLibrary, UWidgetTree, UPanelSlot subclasses."
  },
  {
    "name": "umgeditor.add_widget",
    "description": "Add a UMG widget to a Widget Blueprint's widget tree. Common widgets: UButton, UTextBlock, UImage, UProgressBar, USlider, UCheckBox, UComboBoxString, UEditableText, UListView, UTreeView, UScrollBox, UCanvasPanel, UHorizontalBox, UVerticalBox, UOverlay, USizeBox, UBorder, UGridPanel, UUniformGridPanel, UWidgetSwitcher, UCircularThrobber, URichTextBlock, UBackgroundBlur.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "widget_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Widget Blueprint."
        },
        "widget_class": {
          "type": "string",
          "description": "Widget class to add (e.g. 'Button', 'TextBlock', 'Image', 'VerticalBox', 'CanvasPanel', 'ProgressBar')."
        },
        "widget_name": {
          "type": "string",
          "description": "Name for the widget instance (e.g. 'StartButton', 'HealthText', 'BackgroundImage')."
        },
        "parent_widget": {
          "type": "string",
          "description": "Name of the parent widget in the hierarchy. Empty for root canvas.",
          "default": ""
        },
        "initial_properties": {
          "type": "object",
          "description": "Initial property values (e.g. {'Text': 'Hello', 'ColorAndOpacity': '(R=1,G=0,B=0,A=1)'}).",
          "additionalProperties": true,
          "default": {}
        }
      },
      "additionalProperties": false,
      "required": ["widget_blueprint_path", "widget_class", "widget_name"]
    }
  },
  {
    "name": "umgeditor.set_widget_slot",
    "description": "Configure a widget's slot properties based on its parent panel type. Canvas Panel slots have anchors/position/size/alignment. Horizontal/Vertical Box slots have padding/size/alignment. Overlay slots have HAlign/VAlign/padding. Grid Panel slots have row/column. Uses UPanelSlot (UCanvasPanelSlot, UHorizontalBoxSlot, etc.).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "widget_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Widget Blueprint."
        },
        "widget_name": {
          "type": "string",
          "description": "Name of the widget whose slot to configure."
        },
        "slot_properties": {
          "type": "object",
          "description": "Slot properties. For CanvasPanel: {anchors_min, anchors_max, position, size, alignment, auto_size, z_order}. For Box: {padding, size_rule, size_value, h_align, v_align}. For Overlay: {h_align, v_align, padding}.",
          "additionalProperties": true
        }
      },
      "additionalProperties": false,
      "required": ["widget_blueprint_path", "widget_name", "slot_properties"]
    }
  },
  {
    "name": "umgeditor.bind_property",
    "description": "Create a property binding on a UMG widget. Bindings dynamically update widget properties from Blueprint functions or variables. Common bindings: Text content, Visibility, ColorAndOpacity, IsEnabled, BrushColor, Percent (ProgressBar). The binding function must return the correct type for the property.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "widget_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Widget Blueprint."
        },
        "widget_name": {
          "type": "string",
          "description": "Widget to bind."
        },
        "property_name": {
          "type": "string",
          "description": "Property to bind (e.g. 'Text', 'Visibility', 'ColorAndOpacity', 'Percent', 'IsEnabled')."
        },
        "binding_function": {
          "type": "string",
          "description": "Name of the function in the Widget Blueprint that returns the bound value."
        }
      },
      "additionalProperties": false,
      "required": ["widget_blueprint_path", "widget_name", "property_name", "binding_function"]
    }
  },
  {
    "name": "umgeditor.add_animation",
    "description": "Add a widget animation (UWidgetAnimation) to a Widget Blueprint. Widget animations use UMG's built-in sequencer to animate widget properties over time: position, scale, opacity, color, render transform, padding, etc. Animations can be played/paused/reversed from Blueprint logic.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "widget_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Widget Blueprint."
        },
        "animation_name": {
          "type": "string",
          "description": "Name for the animation (e.g. 'FadeIn', 'SlideFromLeft', 'PulseHighlight')."
        },
        "duration": {
          "type": "number",
          "description": "Animation duration in seconds.",
          "default": 1.0
        },
        "target_widgets": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Widget names to animate.",
          "default": []
        },
        "looping": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["widget_blueprint_path", "animation_name"]
    }
  },
  {
    "name": "umgeditor.list_widget_tree",
    "description": "List the complete widget hierarchy tree of a Widget Blueprint. Returns each widget's name, class, parent, slot type, visibility, and basic properties. Essential for understanding the UI layout before modifications.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "widget_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Widget Blueprint."
        },
        "include_properties": {
          "type": "boolean",
          "description": "Include widget property values.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["widget_blueprint_path"]
    }
  },
  {
    "name": "umgeditor.set_widget_style",
    "description": "Set visual style properties on a UMG widget: colors, fonts, brushes, opacity, render transform, visibility, cursor, tool tip. Each widget type has specific style properties  UButton has NormalStyle/HoveredStyle/PressedStyle, UTextBlock has Font/ColorAndOpacity, UImage has Brush, etc.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "widget_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Widget Blueprint."
        },
        "widget_name": {
          "type": "string",
          "description": "Widget to style."
        },
        "style_properties": {
          "type": "object",
          "description": "Style properties to set. Keys are property names, values are the style values. Examples: {'RenderOpacity': 0.8, 'Visibility': 'Visible', 'ColorAndOpacity': '(R=1,G=1,B=1,A=1)'}.",
          "additionalProperties": true
        }
      },
      "additionalProperties": false,
      "required": ["widget_blueprint_path", "widget_name", "style_properties"]
    }
  },

  {
    "_comment": "=== UNDO HISTORY === (API: Editor/UndoHistoryEditor, Editor/UnrealEd)  Undo/redo transaction management. Uses GEditor->Trans (UTransBuffer), FScopedTransaction, FTransactionContext. The editor maintains a transaction history of all undoable operations."
  },
  {
    "name": "undohistory.undo",
    "description": "Undo the last editor transaction. Reverses the most recent undoable operation (actor transform, property change, node creation, etc.). Uses GEditor->UndoTransaction(). Multiple calls undo multiple steps.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "count": {
          "type": "integer",
          "description": "Number of undo steps to perform.",
          "default": 1
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "undohistory.redo",
    "description": "Redo the last undone transaction. Re-applies a previously undone operation. Uses GEditor->RedoTransaction().",
    "inputSchema": {
      "type": "object",
      "properties": {
        "count": {
          "type": "integer",
          "description": "Number of redo steps to perform.",
          "default": 1
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "undohistory.list",
    "description": "List the undo/redo transaction history. Shows all undoable and redoable operations with their descriptions, timestamps, and object counts. Uses UTransBuffer::GetUndoContext/GetRedoContext.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "max_entries": {
          "type": "integer",
          "description": "Maximum number of history entries to return.",
          "default": 20
        },
        "include_redo": {
          "type": "boolean",
          "description": "Include redo (future) transactions.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== UAT / BUILD SYSTEM === (API: Editor/UATHelper, Runtime/Projects)  Unreal Automation Tool operations: cook, build, package, commandlets, build targets. UATHelper provides editor integration for UAT commands. Also covers build configuration management."
  },
  {
    "name": "uat.cook_content",
    "description": "Cook content for a target platform. Cooking converts assets from editor format to platform-optimized runtime format. Uses UAT command: BuildCookRun with cook parameters. Platform options: Windows, Linux, Mac, Android, IOS, PS5, XSX.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "platform": {
          "type": "string",
          "enum": ["Windows", "Linux", "Mac", "Android", "IOS"],
          "description": "Target platform."
        },
        "maps": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Specific maps to cook. Empty for all maps.",
          "default": []
        },
        "iterative": {
          "type": "boolean",
          "description": "Use iterative cooking (only cook changed content).",
          "default": true
        },
        "compressed": {
          "type": "boolean",
          "description": "Compress cooked data.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["platform"]
    }
  },
  {
    "name": "uat.package_project",
    "description": "Package the project for distribution. Full BuildCookRun pipeline: compile, cook, stage, package. Produces a standalone executable build. Uses UAT BuildCookRun command with -package flag.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "platform": {
          "type": "string",
          "enum": ["Windows", "Linux", "Mac", "Android", "IOS"],
          "description": "Target platform."
        },
        "configuration": {
          "type": "string",
          "enum": ["Development", "Shipping", "Debug", "Test"],
          "default": "Development"
        },
        "output_directory": {
          "type": "string",
          "description": "Output directory for the packaged build.",
          "default": ""
        },
        "archive": {
          "type": "boolean",
          "description": "Archive the build after packaging.",
          "default": false
        },
        "server": {
          "type": "boolean",
          "description": "Also build a dedicated server.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["platform"]
    }
  },
  {
    "name": "uat.run_commandlet",
    "description": "Run a UE commandlet. Commandlets are command-line utilities that run within the engine: ResavePackages, DiffPackages, FixupRedirects, GatherText, ImportLocalizedDialogue, ContentValidation, etc. Uses UCommandlet subclasses.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "commandlet_name": {
          "type": "string",
          "description": "Commandlet name (e.g. 'ResavePackages', 'FixupRedirects', 'DiffPackages', 'GatherText', 'ContentValidation')."
        },
        "arguments": {
          "type": "string",
          "description": "Additional command-line arguments for the commandlet.",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": ["commandlet_name"]
    }
  },
  {
    "name": "uat.get_build_status",
    "description": "Get the current build/cook status. Returns whether a build or cook process is currently running, progress percentage, any errors/warnings, and the output log tail.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "include_log_tail": {
          "type": "boolean",
          "description": "Include the last N lines of build output.",
          "default": true
        },
        "log_lines": {
          "type": "integer",
          "description": "Number of log lines to return.",
          "default": 20
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "uat.build_target",
    "description": "Build a specific target configuration using UnrealBuildTool. Compile the project for a specific platform and configuration without cooking or packaging. Returns compilation status and errors.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "target": {
          "type": "string",
          "enum": ["Editor", "Game", "Client", "Server"],
          "description": "Build target type.",
          "default": "Editor"
        },
        "platform": {
          "type": "string",
          "enum": ["Win64", "Linux", "Mac", "Android", "IOS"],
          "default": "Win64"
        },
        "configuration": {
          "type": "string",
          "enum": ["Debug", "DebugGame", "Development", "Shipping", "Test"],
          "default": "Development"
        },
        "clean": {
          "type": "boolean",
          "description": "Clean build (rebuild all).",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== GAMEPLAY DEBUGGER === (API: Editor/GameplayDebuggerEditor, Runtime/GameplayDebugger)  Gameplay Debugger categories, activation, and configuration. The Gameplay Debugger overlays debug info on screen during play: AI, EQS, NavMesh, Perception, Abilities, etc."
  },
  {
    "name": "gameplaydebugger.toggle",
    "description": "Toggle the Gameplay Debugger on or off during PIE. The Gameplay Debugger shows real-time debug overlays for AI, navigation, perception, abilities, and more. Default key: apostrophe (').",
    "inputSchema": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "True to enable, false to disable."
        }
      },
      "additionalProperties": false,
      "required": ["enabled"]
    }
  },
  {
    "name": "gameplaydebugger.enable_category",
    "description": "Enable or disable a specific Gameplay Debugger category. Categories control which debug overlays are shown: AI, BehaviorTree, EQS, NavMesh, Perception, Abilities, Animation, etc. Each category can be toggled with numpad keys during play.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "category": {
          "type": "string",
          "description": "Category name (e.g. 'AI', 'BehaviorTree', 'EQS', 'NavMesh', 'Perception', 'Abilities', 'Animation')."
        },
        "enabled": {
          "type": "boolean",
          "description": "Enable or disable the category."
        }
      },
      "additionalProperties": false,
      "required": ["category", "enabled"]
    }
  },
  {
    "name": "gameplaydebugger.list_categories",
    "description": "List all registered Gameplay Debugger categories with their enabled/disabled state, slot bindings, and descriptions. Returns both engine and project custom categories.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "include_disabled": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== CLASS VIEWER === (API: Editor/ClassViewer)  Class browser/hierarchy viewer: browse placeable classes, search by parent, get class metadata. Uses FClassViewerModule, FClassViewerInitializationOptions, IClassViewerFilter."
  },
  {
    "name": "classviewer.browse",
    "description": "Browse the UE class hierarchy with filters. Returns a filtered list of classes based on parent class, placeable status, Blueprint-spawnable status, or module. Equivalent to the Editor's Class Viewer window. Uses FClassViewerModule.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "parent_class": {
          "type": "string",
          "description": "Filter to subclasses of this parent (e.g. 'AActor', 'UActorComponent', 'UObject').",
          "default": "UObject"
        },
        "filter": {
          "type": "string",
          "description": "Name substring filter.",
          "default": ""
        },
        "placeable_only": {
          "type": "boolean",
          "description": "Only show classes that can be placed in levels.",
          "default": false
        },
        "blueprint_bases_only": {
          "type": "boolean",
          "description": "Only show classes that can be used as Blueprint parent classes.",
          "default": false
        },
        "max_results": {
          "type": "integer",
          "default": 50
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "classviewer.get_class_info",
    "description": "Get detailed information about a specific UClass: module, header file path, parent class, interfaces, class flags (Abstract, Deprecated, Transient, etc.), config file, metadata, Blueprint type (if applicable), CDO properties, and component templates.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "class_name": {
          "type": "string",
          "description": "Class name (e.g. 'ACharacter', 'UStaticMeshComponent', 'UGameplayAbility')."
        },
        "include_metadata": {
          "type": "boolean",
          "description": "Include class metadata (UCLASS specifiers, meta tags).",
          "default": true
        },
        "include_cdo": {
          "type": "boolean",
          "description": "Include Class Default Object property values.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["class_name"]
    }
  },
  {
    "name": "classviewer.list_placeable_actors",
    "description": "List all actor classes that can be placed in levels via the Place Actors panel. Returns class name, display name, category, and spawn requirements. Includes both C++ and Blueprint actor classes.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "category_filter": {
          "type": "string",
          "description": "Filter by placement category (e.g. 'Basic', 'Lights', 'Cinematics', 'Volumes', 'All Classes').",
          "default": ""
        },
        "name_filter": {
          "type": "string",
          "description": "Name substring filter.",
          "default": ""
        },
        "include_plugins": {
          "type": "boolean",
          "description": "Include actor classes from plugins.",
          "default": true
        },
        "max_results": {
          "type": "integer",
          "default": 50
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "classviewer.get_module_classes",
    "description": "List all UClasses defined in a specific module. Useful for discovering available types from engine modules or project modules. Returns class name, parent, and whether it's abstract/deprecated.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "module_name": {
          "type": "string",
          "description": "Module name (e.g. 'Engine', 'GameplayAbilities', 'NavigationSystem', 'AIModule', your project module name)."
        },
        "filter": {
          "type": "string",
          "description": "Name substring filter.",
          "default": ""
        },
        "max_results": {
          "type": "integer",
          "default": 100
        }
      },
      "additionalProperties": false,
      "required": ["module_name"]
    }
  },

  {
    "_comment": "=== GRAPH EDITOR === (API: Editor/GraphEditor)  Generic graph editor operations that work across all UEdGraph types: Blueprint, Material, AnimBP, Niagara, MetaSound, BehaviorTree, StateTree. SGraphEditor, SGraphPanel, UEdGraphNode, UEdGraphPin, FEdGraphSchemaAction."
  },
  {
    "name": "grapheditor.create_subgraph",
    "description": "Create a new sub-graph in a Blueprint or other graph-based asset. In Blueprints, this creates a new EventGraph, collapsed graph, or sub-animation graph. Uses FBlueprintEditorUtils::AddNewGraph.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Asset path of the graph-owning asset."
        },
        "graph_name": {
          "type": "string",
          "description": "Name for the new sub-graph."
        },
        "graph_type": {
          "type": "string",
          "enum": ["event_graph", "function", "macro", "collapsed", "animation", "state_machine"],
          "description": "Type of graph to create.",
          "default": "event_graph"
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "graph_name"]
    }
  },
  {
    "name": "grapheditor.delete_nodes",
    "description": "Delete specific nodes from a graph by name or index. Uses UEdGraphNode::DestroyNode and FBlueprintEditorUtils::RemoveNode. Handles proper cleanup of pin connections.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Asset path."
        },
        "graph_name": {
          "type": "string",
          "description": "Graph containing the nodes.",
          "default": "EventGraph"
        },
        "node_names": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Names/titles of nodes to delete."
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "node_names"]
    }
  },
  {
    "name": "grapheditor.auto_arrange",
    "description": "Auto-arrange/layout nodes in a graph for readability. Organizes nodes into a clean left-to-right flow layout based on execution/data pin connections. Reduces visual clutter. Uses graph layout algorithms.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Asset path."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "horizontal_spacing": {
          "type": "number",
          "description": "Horizontal spacing between nodes.",
          "default": 200
        },
        "vertical_spacing": {
          "type": "number",
          "description": "Vertical spacing between parallel branches.",
          "default": 100
        }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "grapheditor.select_nodes",
    "description": "Select nodes in a graph by name, type, or pattern. Selection is set in the graph editor UI, enabling subsequent operations like copy, delete, align, or collapse. Uses SGraphEditor::SetNodeSelection.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Asset path."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "node_names": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Specific node names to select.",
          "default": []
        },
        "node_class_filter": {
          "type": "string",
          "description": "Select all nodes of this K2Node class type (e.g. 'UK2Node_CallFunction').",
          "default": ""
        },
        "select_all": {
          "type": "boolean",
          "description": "Select all nodes in the graph.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "grapheditor.collapse_nodes",
    "description": "Collapse selected nodes into a function or macro. Takes a group of connected nodes and wraps them into a new function graph or macro graph with appropriate input/output pins. Uses FBlueprintEditorUtils::CollapseNodes. The inverse of 'Expand Node'.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Asset path of the Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "EventGraph"
        },
        "node_names": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Node names to collapse together."
        },
        "collapse_type": {
          "type": "string",
          "enum": ["function", "macro", "collapsed_graph"],
          "description": "What to collapse nodes into.",
          "default": "function"
        },
        "new_name": {
          "type": "string",
          "description": "Name for the new function/macro.",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": ["asset_path", "node_names"]
    }
  },

  {
    "_comment": "=== ANIMATION WARPING === (API: Plugins/AnimationWarping)  Orientation warping, stride warping, and slope warping anim graph nodes. UAnimGraphNode_OrientationWarping, UAnimGraphNode_StrideWarping, UAnimGraphNode_SlopeWarping. These nodes modify animation poses to match character movement direction and surface slope at runtime."
  },
  {
    "name": "animwarping.add_orientation_warping",
    "description": "Add an Orientation Warping node (UAnimGraphNode_OrientationWarping) to an AnimBP. Orientation warping rotates the character's spine/pelvis bones to face the movement direction while keeping feet planted. This avoids needing separate directional animations (Fwd/Bwd/Left/Right). Requires: locomotion direction angle input, spine bone chain config.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Animation Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "AnimGraph"
        },
        "spine_bones": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Spine bone names to rotate (e.g. ['spine_01', 'spine_02', 'spine_03']). Warping is distributed across these bones.",
          "default": []
        },
        "ik_foot_bones": {
          "type": "array",
          "items": { "type": "string" },
          "description": "IK foot bone names for foot locking (e.g. ['ik_foot_l', 'ik_foot_r']).",
          "default": []
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path"]
    }
  },
  {
    "name": "animwarping.add_stride_warping",
    "description": "Add a Stride Warping node (UAnimGraphNode_StrideWarping) to an AnimBP. Stride warping scales the stride length of locomotion animations to match the character's actual movement speed. This allows a single walk/run animation to cover different speeds without foot sliding. Inputs: locomotion speed, stride scale.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Animation Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "AnimGraph"
        },
        "pelvis_bone": {
          "type": "string",
          "description": "Pelvis/hip bone name for vertical offset adjustment.",
          "default": "pelvis"
        },
        "ik_foot_bones": {
          "type": "array",
          "items": { "type": "string" },
          "description": "IK foot bone names (e.g. ['ik_foot_l', 'ik_foot_r']).",
          "default": []
        },
        "floor_normal_direction": {
          "type": "string",
          "enum": ["z_up", "gravity"],
          "default": "z_up"
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path"]
    }
  },
  {
    "name": "animwarping.add_slope_warping",
    "description": "Add a Slope Warping node (UAnimGraphNode_SlopeWarping) to an AnimBP. Slope warping adjusts foot placement and leg IK to match surface slope, preventing foot penetration on hills and stairs. Works with the gravity direction and floor normal to compute proper foot transforms.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Animation Blueprint."
        },
        "graph_name": {
          "type": "string",
          "default": "AnimGraph"
        },
        "ik_foot_definitions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "foot_bone": { "type": "string" },
              "ik_foot_bone": { "type": "string" },
              "num_bones_in_limb": { "type": "integer", "default": 2 }
            }
          },
          "description": "Foot/IK foot bone pairs for each leg.",
          "default": []
        },
        "pelvis_bone": {
          "type": "string",
          "default": "pelvis"
        },
        "node_position": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
          "default": { "x": 0, "y": 0 }
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path"]
    }
  },
  {
    "name": "animwarping.configure_warping",
    "description": "Configure warping settings on an existing orientation/stride/slope warping node. Settings include warping alpha, interp speed, offset clamping, foot locking, blend parameters, and per-bone rotation distribution weights.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Animation Blueprint."
        },
        "node_name": {
          "type": "string",
          "description": "Name of the warping node to configure."
        },
        "settings": {
          "type": "object",
          "properties": {
            "warping_alpha": { "type": "number", "description": "Blend alpha for warping effect (0-1)." },
            "rotation_interp_speed": { "type": "number", "description": "Interpolation speed for rotation changes." },
            "max_offset_angle": { "type": "number", "description": "Maximum rotation offset in degrees." },
            "enable_foot_locking": { "type": "boolean" },
            "stride_scale_modifier": { "type": "number" }
          },
          "additionalProperties": true
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path", "node_name", "settings"]
    }
  },

  {
    "_comment": "=== MOTION TRAJECTORY === (API: Plugins/MotionTrajectory)  Motion trajectory prediction and history for animation matching. UCharacterTrajectoryComponent stores past/future trajectory samples (position, velocity, facing). Used by Pose Search (Motion Matching) and choosers to pick best-matching animation. FTrajectorySample, FTrajectoryPoint."
  },
  {
    "name": "motiontrajectory.add_trajectory_component",
    "description": "Add a CharacterTrajectoryComponent to an actor Blueprint. UCharacterTrajectoryComponent automatically records the character's movement history and predicts future trajectory. It is consumed by Pose Search (Motion Matching), Animation Choosers, and Distance Matching systems to select animations that best match the character's current and predicted movement.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the actor Blueprint (usually a Character BP)."
        },
        "component_name": {
          "type": "string",
          "description": "Name for the trajectory component.",
          "default": "TrajectoryComponent"
        },
        "history_length": {
          "type": "number",
          "description": "Duration of trajectory history to keep (seconds).",
          "default": 1.0
        },
        "prediction_length": {
          "type": "number",
          "description": "Duration of future trajectory to predict (seconds).",
          "default": 1.0
        },
        "sample_rate": {
          "type": "integer",
          "description": "Number of trajectory samples per second.",
          "default": 30
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },
  {
    "name": "motiontrajectory.configure_prediction",
    "description": "Configure the trajectory prediction parameters on a CharacterTrajectoryComponent. Controls how future movement is predicted based on current velocity, acceleration, input direction, and character movement mode. Prediction quality directly affects Motion Matching animation selection.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Actor Blueprint asset path."
        },
        "component_name": {
          "type": "string",
          "default": "TrajectoryComponent"
        },
        "prediction_mode": {
          "type": "string",
          "enum": ["velocity", "acceleration", "input_direction", "path_following"],
          "description": "How to predict future trajectory.",
          "default": "velocity"
        },
        "max_speed": {
          "type": "number",
          "description": "Maximum character speed for trajectory clamping.",
          "default": 600.0
        },
        "rotation_prediction": {
          "type": "boolean",
          "description": "Include rotation/facing prediction in trajectory.",
          "default": true
        },
        "use_acceleration": {
          "type": "boolean",
          "description": "Factor in acceleration for more accurate prediction.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },
  {
    "name": "motiontrajectory.get_trajectory_data",
    "description": "Query the current trajectory data from a CharacterTrajectoryComponent at runtime. Returns trajectory samples (past + future) with position, velocity, and facing direction at each sample point. Useful for debugging motion matching and verifying trajectory quality.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor_label": {
          "type": "string",
          "description": "Actor label in the current level."
        },
        "component_name": {
          "type": "string",
          "default": "TrajectoryComponent"
        },
        "include_history": {
          "type": "boolean",
          "default": true
        },
        "include_prediction": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["actor_label"]
    }
  },

  {
    "_comment": "=== SKELETAL MESH MODELING TOOLS === (API: Plugins/SkeletalMeshModelingTools)  In-editor skeletal mesh editing: bone transforms, vertex editing, mesh simplification, LOD authoring. Extends the Modeling Mode tools to work with skeletal meshes. USkeletalMeshModelingToolsModeCustomization, mesh operations on skinned geometry."
  },
  {
    "name": "skeletalmeshmodeling.edit_bone_transform",
    "description": "Edit bone transforms on a skeletal mesh in the reference/bind pose. Modifies the rest pose of specific bones  used for skeleton adjustment without re-importing from DCC tools. Affects all animations using this skeleton. Uses skeletal mesh modeling mode tools.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skeletal_mesh_path": {
          "type": "string",
          "description": "Asset path of the Skeletal Mesh."
        },
        "bone_name": {
          "type": "string",
          "description": "Bone to modify."
        },
        "transform_type": {
          "type": "string",
          "enum": ["location", "rotation", "scale", "all"],
          "default": "all"
        },
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "default": { "x": 0, "y": 0, "z": 0 }
        },
        "rotation": {
          "type": "object",
          "properties": { "pitch": { "type": "number" }, "yaw": { "type": "number" }, "roll": { "type": "number" } },
          "default": { "pitch": 0, "yaw": 0, "roll": 0 }
        },
        "scale": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "default": { "x": 1, "y": 1, "z": 1 }
        },
        "in_component_space": {
          "type": "boolean",
          "description": "If true, transform is in component/model space. If false, in bone-local space.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["skeletal_mesh_path", "bone_name"]
    }
  },
  {
    "name": "skeletalmeshmodeling.simplify_mesh",
    "description": "Simplify (decimate) a skeletal mesh to reduce triangle/vertex count while preserving visual quality and skinning weights. Useful for LOD generation or optimization. Controls: target triangle percentage, max deviation, preserve boundaries, lock normals.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skeletal_mesh_path": {
          "type": "string",
          "description": "Asset path of the Skeletal Mesh."
        },
        "target_percentage": {
          "type": "number",
          "description": "Target percentage of original triangle count (0.0-1.0).",
          "default": 0.5
        },
        "max_deviation": {
          "type": "number",
          "description": "Maximum geometric deviation from original mesh (in cm).",
          "default": 1.0
        },
        "preserve_skinning": {
          "type": "boolean",
          "description": "Preserve skinning weight quality during simplification.",
          "default": true
        },
        "lock_boundaries": {
          "type": "boolean",
          "description": "Lock mesh boundary edges (prevent holes at mesh edges).",
          "default": true
        },
        "target_lod": {
          "type": "integer",
          "description": "LOD index to write simplified mesh to. -1 to replace base mesh.",
          "default": -1
        }
      },
      "additionalProperties": false,
      "required": ["skeletal_mesh_path"]
    }
  },
  {
    "name": "skeletalmeshmodeling.generate_lod",
    "description": "Generate LOD (Level of Detail) entries for a skeletal mesh. Creates simplified mesh versions at specified screen size thresholds. Each LOD can have different reduction settings, material overrides, and bone removal lists.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skeletal_mesh_path": {
          "type": "string",
          "description": "Asset path of the Skeletal Mesh."
        },
        "lod_count": {
          "type": "integer",
          "description": "Number of LODs to generate (excluding LOD0 base mesh).",
          "default": 3
        },
        "reduction_settings": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "screen_size": { "type": "number", "description": "Screen size threshold (0.0-1.0)." },
              "triangle_percent": { "type": "number", "description": "Target triangle percentage." },
              "bones_to_remove": { "type": "array", "items": { "type": "string" }, "default": [] }
            }
          },
          "description": "Per-LOD reduction settings. If empty, auto-generates with default settings.",
          "default": []
        },
        "auto_compute_screen_sizes": {
          "type": "boolean",
          "description": "Automatically compute screen size thresholds.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["skeletal_mesh_path"]
    }
  },

  {
    "_comment": "=== BLEND SPACE MOTION ANALYSIS === (API: Plugins/BlendSpaceMotionAnalysis)  Automatic analysis of animation root motion/bone velocity to compute optimal BlendSpace axis values. FBlendSpaceMotionAnalysis analyzes AnimSequences and recommends Speed/Direction/Angle values for BlendSpace samples."
  },
  {
    "name": "blendspaceanalysis.analyze_motion",
    "description": "Analyze the root motion or bone velocity of animations to compute optimal BlendSpace sample positions. For each AnimSequence, computes average speed, direction angle, and other motion characteristics. This automates the process of placing animations at correct positions in a BlendSpace grid.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_sequences": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Asset paths of AnimSequences to analyze."
        },
        "analysis_type": {
          "type": "string",
          "enum": ["root_motion_speed", "root_motion_direction", "bone_velocity", "locomotion_angle"],
          "description": "What motion characteristic to analyze.",
          "default": "root_motion_speed"
        },
        "bone_name": {
          "type": "string",
          "description": "Bone to analyze (for bone_velocity analysis type).",
          "default": "root"
        },
        "analysis_axis": {
          "type": "string",
          "enum": ["x", "y", "z", "xy", "xz", "xyz"],
          "description": "Axis/axes to compute velocity on.",
          "default": "xy"
        }
      },
      "additionalProperties": false,
      "required": ["anim_sequences"]
    }
  },
  {
    "name": "blendspaceanalysis.auto_populate_blendspace",
    "description": "Automatically populate a BlendSpace with AnimSequences based on motion analysis. Analyzes each animation's root motion characteristics and places them at computed axis positions in the BlendSpace. Replaces manual drag-and-drop sample placement.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blend_space_path": {
          "type": "string",
          "description": "Asset path of the BlendSpace to populate."
        },
        "anim_sequences": {
          "type": "array",
          "items": { "type": "string" },
          "description": "AnimSequence paths to analyze and place."
        },
        "x_axis_analysis": {
          "type": "string",
          "enum": ["speed", "direction", "custom"],
          "description": "What motion property maps to X axis.",
          "default": "speed"
        },
        "y_axis_analysis": {
          "type": "string",
          "enum": ["speed", "direction", "custom", "none"],
          "description": "What motion property maps to Y axis (for 2D BlendSpaces).",
          "default": "direction"
        },
        "clear_existing": {
          "type": "boolean",
          "description": "Remove existing samples before populating.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["blend_space_path", "anim_sequences"]
    }
  },

  {
    "_comment": "=== JSON BLUEPRINT UTILITIES === (API: Plugins/JsonBlueprintUtilities)  JSON data handling in Blueprints. UJsonBlueprintFunctionLibrary provides BP-callable JSON parse/stringify/query operations. FJsonObjectWrapper wraps TSharedPtr<FJsonObject> for Blueprint use. Enables data-driven design patterns."
  },
  {
    "name": "jsonblueprint.parse_json",
    "description": "Parse a JSON string into a JsonObject that can be queried from Blueprints. Uses FJsonObjectWrapper which wraps TSharedPtr<FJsonObject>. The parsed object can be passed to other Blueprint nodes for field access. Supports nested objects, arrays, and all JSON value types.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "json_string": {
          "type": "string",
          "description": "Raw JSON string to parse."
        },
        "validate_only": {
          "type": "boolean",
          "description": "If true, only validate the JSON syntax without creating an object.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["json_string"]
    }
  },
  {
    "name": "jsonblueprint.get_field",
    "description": "Get a field value from a JSON object by key path. Supports dot-notation for nested access (e.g. 'player.stats.health') and array indexing (e.g. 'items[0].name'). Returns the value as string, number, bool, object, or array depending on the field type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "json_string": {
          "type": "string",
          "description": "JSON string to query."
        },
        "field_path": {
          "type": "string",
          "description": "Dot-notation path to the field (e.g. 'player.stats.health', 'items[0].name')."
        },
        "default_value": {
          "type": "string",
          "description": "Default value if field not found.",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": ["json_string", "field_path"]
    }
  },
  {
    "name": "jsonblueprint.set_field",
    "description": "Set or add a field value in a JSON object. Returns the modified JSON string. Supports creating nested paths automatically. Value type is inferred from the input (number, bool, string, object, array).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "json_string": {
          "type": "string",
          "description": "JSON string to modify."
        },
        "field_path": {
          "type": "string",
          "description": "Dot-notation path for the field to set."
        },
        "value": {
          "type": "string",
          "description": "Value to set (as string; type is auto-inferred: '42'  number, 'true'  bool, '{...}'  object)."
        }
      },
      "additionalProperties": false,
      "required": ["json_string", "field_path", "value"]
    }
  },
  {
    "name": "jsonblueprint.load_json_file",
    "description": "Load a JSON file from disk into a Blueprint-usable JsonObject. Files can be project-relative (e.g. 'Config/MyData.json') or absolute paths. The loaded JSON can be queried with get_field operations.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "file_path": {
          "type": "string",
          "description": "Path to JSON file (project-relative or absolute)."
        }
      },
      "additionalProperties": false,
      "required": ["file_path"]
    }
  },
  {
    "name": "jsonblueprint.save_json_file",
    "description": "Save a JSON string to a file on disk. Writes formatted (pretty-printed) JSON. Useful for saving game configuration, exported data, or debug dumps.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "json_string": {
          "type": "string",
          "description": "JSON string to write."
        },
        "file_path": {
          "type": "string",
          "description": "Output file path (project-relative or absolute)."
        },
        "pretty_print": {
          "type": "boolean",
          "description": "Format with indentation.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["json_string", "file_path"]
    }
  },

  {
    "_comment": "=== PROPERTY ACCESS === (API: Plugins/PropertyAccessNode)  Property Access system for efficient property binding in AnimBP and other contexts. UPropertyAccessNode allows binding properties by path string (e.g. 'Character.MovementComponent.Velocity.Size') that compiles into optimized direct-access code. Avoids Blueprint VM overhead for hot paths like AnimBP per-frame reads."
  },
  {
    "name": "propertyaccess.add_binding",
    "description": "Add a Property Access binding in an Animation Blueprint or other property-access-enabled context. Property Access bindings provide a compiled, high-performance path to read property values without Blueprint VM overhead. Common in AnimBP for reading character movement data: velocity, speed, direction, ground state, etc. Path examples: 'Character.GetMovementComponent().Velocity', 'Character.bIsCrouched'.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Animation Blueprint."
        },
        "source_path": {
          "type": "string",
          "description": "Property access path string (e.g. 'Character.GetCharacterMovement().Velocity.Size()', 'bIsFalling')."
        },
        "target_variable": {
          "type": "string",
          "description": "Blueprint variable to bind the property value to."
        },
        "copy_type": {
          "type": "string",
          "enum": ["copy", "reference", "getter_setter"],
          "description": "How to access the property: 'copy' copies value each tick, 'reference' provides a ref.",
          "default": "copy"
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path", "source_path", "target_variable"]
    }
  },
  {
    "name": "propertyaccess.list_accessible_properties",
    "description": "List all properties accessible via Property Access paths from a given context class. Returns valid path segments and their types, helping construct proper property access bindings. Shows the same suggestions as the Property Access dropdown in the AnimBP editor.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "context_class": {
          "type": "string",
          "description": "Class to enumerate accessible properties for (e.g. 'ACharacter', 'UCharacterMovementComponent')."
        },
        "path_prefix": {
          "type": "string",
          "description": "Optional prefix to filter paths (e.g. 'MovementComponent.' to see sub-properties).",
          "default": ""
        },
        "max_depth": {
          "type": "integer",
          "description": "Maximum depth of property path traversal.",
          "default": 3
        },
        "max_results": {
          "type": "integer",
          "default": 50
        }
      },
      "additionalProperties": false,
      "required": ["context_class"]
    }
  },
  {
    "name": "propertyaccess.validate_path",
    "description": "Validate a property access path string against a context class. Checks that each segment of the path resolves to a valid property or function, and returns the final resolved type. Useful for debugging 'Property Access Path Not Found' compilation errors.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "context_class": {
          "type": "string",
          "description": "Context class name."
        },
        "access_path": {
          "type": "string",
          "description": "Property access path to validate."
        }
      },
      "additionalProperties": false,
      "required": ["context_class", "access_path"]
    }
  },

  {
    "_comment": "=== BLUEPRINT STATS === (API: Plugins/BlueprintStats)  Blueprint complexity analysis and statistics. FBlueprintStats computes node counts, nesting depth, graph complexity, variable usage, cast frequency, and other metrics. Helps identify Blueprints that should be refactored to C++ for performance."
  },
  {
    "name": "blueprintstats.analyze",
    "description": "Analyze a Blueprint's complexity and generate statistics. Returns: total node count, function count, macro count, variable count, event count, max nesting depth, cast count, tick enabled status, estimated compile time, and a complexity score. Blueprints with high complexity scores are candidates for C++ refactoring.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Asset path of the Blueprint to analyze."
        },
        "include_graph_breakdown": {
          "type": "boolean",
          "description": "Include per-graph node count breakdown.",
          "default": true
        },
        "include_node_types": {
          "type": "boolean",
          "description": "Include breakdown of node types (K2Node_CallFunction, K2Node_IfThenElse, etc.).",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },
  {
    "name": "blueprintstats.batch_analyze",
    "description": "Analyze multiple Blueprints and rank them by complexity. Returns a sorted list of Blueprints with their complexity scores, node counts, and recommendations. Useful for project-wide optimization audits.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "search_path": {
          "type": "string",
          "description": "Content path to search for Blueprints.",
          "default": "/Game"
        },
        "sort_by": {
          "type": "string",
          "enum": ["complexity", "node_count", "function_count", "variable_count", "compile_time"],
          "default": "complexity"
        },
        "min_nodes": {
          "type": "integer",
          "description": "Only include Blueprints with at least this many nodes.",
          "default": 10
        },
        "max_results": {
          "type": "integer",
          "default": 25
        },
        "blueprint_type_filter": {
          "type": "string",
          "enum": ["all", "actor", "widget", "anim", "component"],
          "description": "Filter by Blueprint type.",
          "default": "all"
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== BLUEPRINT FILE UTILS === (API: Plugins/BlueprintFileUtils)  File I/O utilities exposed to Blueprints. UBlueprintFileUtilsBPLibrary provides BP-callable functions: ReadFile, WriteFile, ListFiles, FileExists, DirectoryExists, CreateDirectory, etc. Enables Blueprint scripts to interact with the file system for data import/export, logging, config management."
  },
  {
    "name": "blueprintfileutils.read_file",
    "description": "Read a text file from disk into a string (Blueprint-accessible). Supports project-relative and absolute paths. Uses UBlueprintFileUtilsBPLibrary::ReadFile. Returns the full file contents as a string.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "file_path": {
          "type": "string",
          "description": "File path to read (project-relative or absolute)."
        },
        "encoding": {
          "type": "string",
          "enum": ["utf8", "utf16", "ascii", "auto"],
          "default": "auto"
        }
      },
      "additionalProperties": false,
      "required": ["file_path"]
    }
  },
  {
    "name": "blueprintfileutils.write_file",
    "description": "Write a string to a text file on disk. Creates the file if it doesn't exist, overwrites if it does. Uses UBlueprintFileUtilsBPLibrary::WriteFile.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "file_path": {
          "type": "string",
          "description": "File path to write to."
        },
        "content": {
          "type": "string",
          "description": "String content to write."
        },
        "append": {
          "type": "boolean",
          "description": "Append to existing file instead of overwriting.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["file_path", "content"]
    }
  },
  {
    "name": "blueprintfileutils.list_files",
    "description": "List files and/or directories at a path. Returns names, sizes, and modification dates. Supports wildcard/extension filtering. Uses UBlueprintFileUtilsBPLibrary.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "directory_path": {
          "type": "string",
          "description": "Directory path to list."
        },
        "extension_filter": {
          "type": "string",
          "description": "File extension filter (e.g. '.json', '.csv', '.txt'). Empty for all files.",
          "default": ""
        },
        "recursive": {
          "type": "boolean",
          "default": false
        },
        "include_directories": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["directory_path"]
    }
  },
  {
    "name": "blueprintfileutils.file_operations",
    "description": "Perform file system operations: check existence, get size, copy, move, or delete files. Batch operation support for multiple files.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": {
          "type": "string",
          "enum": ["exists", "size", "copy", "move", "delete", "create_directory"],
          "description": "File operation to perform."
        },
        "source_path": {
          "type": "string",
          "description": "Source file/directory path."
        },
        "destination_path": {
          "type": "string",
          "description": "Destination path (for copy/move operations).",
          "default": ""
        },
        "overwrite": {
          "type": "boolean",
          "description": "Overwrite destination if it exists (for copy/move).",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["operation", "source_path"]
    }
  },

  {
    "_comment": "=== GAMEPLAY TAGS EDITOR === (API: Plugins/GameplayTagsEditor)  Editor-side GameplayTag management: tag creation, deletion, renaming, tag search, tag tree manipulation. FGameplayTagsEditorModule, IGameplayTagsEditorModule. Complements the runtime GameplayTags module with editor-only tag management operations."
  },
  {
    "name": "gameplaytagseditor.create_tag",
    "description": "Create a new GameplayTag in the project's tag configuration. The tag is added to the specified tag source (DefaultGameplayTags.ini, a DataTable, or a specific .ini file). Tags are hierarchical (e.g. 'Character.State.Jumping'). Uses IGameplayTagsEditorModule::AddNewGameplayTag.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "tag_name": {
          "type": "string",
          "description": "Full tag name with dot-separated hierarchy (e.g. 'Ability.Cooldown.Short', 'Character.State.Dead')."
        },
        "tag_comment": {
          "type": "string",
          "description": "Description/comment for the tag.",
          "default": ""
        },
        "source_file": {
          "type": "string",
          "description": "Tag definition source. 'DefaultGameplayTags' for the project's default tag file, or a specific .ini path.",
          "default": "DefaultGameplayTags"
        }
      },
      "additionalProperties": false,
      "required": ["tag_name"]
    }
  },
  {
    "name": "gameplaytagseditor.rename_tag",
    "description": "Rename a GameplayTag across the entire project. Updates all references in Blueprints, DataTables, configs, and any asset using the tag. This is a project-wide refactor operation. Uses IGameplayTagsEditorModule::RenameTag.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "old_tag": {
          "type": "string",
          "description": "Current tag name to rename."
        },
        "new_tag": {
          "type": "string",
          "description": "New tag name."
        },
        "rename_children": {
          "type": "boolean",
          "description": "Also rename child tags (e.g. renaming 'A.B' to 'X.Y' also renames 'A.B.C' to 'X.Y.C').",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["old_tag", "new_tag"]
    }
  },
  {
    "name": "gameplaytagseditor.delete_tag",
    "description": "Delete a GameplayTag from the project. Removes the tag definition and optionally its children. WARNING: Assets referencing deleted tags may produce errors. Check references first with search_tags.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "tag_name": {
          "type": "string",
          "description": "Tag name to delete."
        },
        "delete_children": {
          "type": "boolean",
          "description": "Also delete child tags.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": ["tag_name"]
    }
  },
  {
    "name": "gameplaytagseditor.search_tags",
    "description": "Search for GameplayTags by name pattern. Returns matching tags with their sources (which .ini file or DataTable defines them), comments, and usage counts. Also returns the tag hierarchy structure.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "search_pattern": {
          "type": "string",
          "description": "Tag name search pattern (substring match). E.g. 'Character.State' returns all state tags."
        },
        "include_sources": {
          "type": "boolean",
          "description": "Include the source file for each tag.",
          "default": true
        },
        "include_children": {
          "type": "boolean",
          "description": "Also return child tags of matches.",
          "default": true
        },
        "max_results": {
          "type": "integer",
          "default": 100
        }
      },
      "additionalProperties": false,
      "required": ["search_pattern"]
    }
  },
  {
    "name": "gameplaytagseditor.get_tag_tree",
    "description": "Get the full GameplayTag hierarchy tree from a root tag. Returns the complete tree structure with all children, organized hierarchically. Useful for understanding tag organization and discovering available tags.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root_tag": {
          "type": "string",
          "description": "Root tag to display tree from. Empty for full tree.",
          "default": ""
        },
        "max_depth": {
          "type": "integer",
          "description": "Maximum depth to traverse.",
          "default": 10
        },
        "include_counts": {
          "type": "boolean",
          "description": "Include reference counts for each tag.",
          "default": false
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== SCRIPTABLE TOOLS === (API: Plugins/ScriptableToolsEditorMode, Plugins/ScriptableToolsFramework)  Framework for creating custom interactive editor tools via Blueprints/Python. UScriptableInteractiveTool, UScriptableClickDragTool, UScriptableSingleClickTool. Tools appear in the editor's Modeling Mode or custom mode and respond to click/drag/hover in viewport."
  },
  {
    "name": "scriptabletools.create_tool",
    "description": "Create a new Scriptable Interactive Tool Blueprint. Scriptable tools are custom editor viewport tools created via Blueprint (no C++ needed). They appear in the Modeling Mode tool palette or a custom mode. Derive from UScriptableInteractiveTool, UScriptableClickDragTool, or UScriptableSingleClickTool. Override OnClicked, OnDragBegin, OnDragUpdate, OnHoverUpdate for interactivity.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Path for the new tool Blueprint (e.g. /Game/EditorTools/ST_VertexPainter)."
        },
        "tool_type": {
          "type": "string",
          "enum": ["interactive", "click_drag", "single_click"],
          "description": "'interactive' for full interaction, 'click_drag' for click-and-drag workflows, 'single_click' for point-and-click.",
          "default": "interactive"
        },
        "display_name": {
          "type": "string",
          "description": "Tool display name in the palette.",
          "default": ""
        },
        "category": {
          "type": "string",
          "description": "Tool palette category.",
          "default": "Custom"
        },
        "tooltip": {
          "type": "string",
          "description": "Tooltip text.",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "scriptabletools.register_tool",
    "description": "Register a Scriptable Tool Blueprint with an editor mode so it appears in the tool palette. The tool can be registered with the built-in Modeling Mode or a custom ScriptableToolsEditorMode.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "tool_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Scriptable Tool Blueprint."
        },
        "editor_mode": {
          "type": "string",
          "description": "Editor mode to register with. 'ModelingMode' for the built-in Modeling Mode, or a custom mode name.",
          "default": "ModelingMode"
        },
        "palette_group": {
          "type": "string",
          "description": "Group within the mode's tool palette.",
          "default": "Scripted"
        }
      },
      "additionalProperties": false,
      "required": ["tool_blueprint_path"]
    }
  },
  {
    "name": "scriptabletools.list_tools",
    "description": "List all registered Scriptable Tools in the project. Returns tool names, types, categories, registered editor modes, and Blueprint paths.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "mode_filter": {
          "type": "string",
          "description": "Filter by editor mode name. Empty for all modes.",
          "default": ""
        },
        "include_unregistered": {
          "type": "boolean",
          "description": "Include tool Blueprints not yet registered with any mode.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "scriptabletools.add_tool_property",
    "description": "Add a property (parameter) to a Scriptable Tool that appears in the tool's Details panel when active. Properties can be numeric sliders, checkboxes, dropdowns, color pickers, or asset references. Users adjust these in the editor while using the tool.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "tool_blueprint_path": {
          "type": "string",
          "description": "Asset path of the Scriptable Tool Blueprint."
        },
        "property_name": {
          "type": "string",
          "description": "Name for the tool property."
        },
        "property_type": {
          "type": "string",
          "enum": ["float", "int", "bool", "color", "vector", "string", "enum", "asset_reference"],
          "description": "Property type."
        },
        "default_value": {
          "type": "string",
          "description": "Default value as string.",
          "default": ""
        },
        "display_name": {
          "type": "string",
          "description": "Display name in the Details panel.",
          "default": ""
        },
        "category": {
          "type": "string",
          "description": "Category in the Details panel.",
          "default": "Tool Settings"
        },
        "min_value": {
          "type": "number",
          "description": "Minimum value for numeric properties."
        },
        "max_value": {
          "type": "number",
          "description": "Maximum value for numeric properties."
        }
      },
      "additionalProperties": false,
      "required": ["tool_blueprint_path", "property_name", "property_type"]
    }
  },

  {
    "_comment": "=== AI SUPPORT === (API: Plugins/AISupport)  Core AI utility classes that extend the AIModule. FAISupportModule, AI debugging helpers, AI test suite utilities, behavior tree service/decorator base classes, perception stimulus helpers. Provides foundational AI infrastructure used by BehaviorTree, EQS, HTN, and other AI systems."
  },
  {
    "name": "aisupport.configure_ai_controller",
    "description": "Configure an AI Controller on an actor. Sets the AI controller class, auto-possess settings, pathfinding configuration, and perception component setup. AIControllers drive BehaviorTrees, EQS queries, and other AI logic.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Character/Pawn Blueprint asset path."
        },
        "ai_controller_class": {
          "type": "string",
          "description": "AI Controller class name (e.g. 'AIController', 'MyAIController').",
          "default": "AIController"
        },
        "auto_possess_ai": {
          "type": "string",
          "enum": ["disabled", "placed_in_world", "spawned", "placed_in_world_or_spawned"],
          "default": "placed_in_world_or_spawned"
        },
        "behavior_tree_path": {
          "type": "string",
          "description": "BehaviorTree asset to run automatically.",
          "default": ""
        },
        "use_pathfinding": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },
  {
    "name": "aisupport.manage_ai_stimulus",
    "description": "Register or configure AI perception stimuli on actors. Stimuli make actors detectable by AI perception senses (sight, hearing, damage, etc.). Configure stimulus tags, age, strength, and custom sense associations.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor_label": {
          "type": "string",
          "description": "Actor label in the level."
        },
        "operation": {
          "type": "string",
          "enum": ["register_source", "unregister_source", "report_event", "list_stimuli"],
          "description": "Stimulus operation."
        },
        "sense_class": {
          "type": "string",
          "enum": ["sight", "hearing", "damage", "touch", "team", "prediction", "custom"],
          "description": "AI sense type.",
          "default": "sight"
        },
        "stimulus_tag": {
          "type": "string",
          "description": "GameplayTag for custom stimulus identification.",
          "default": ""
        },
        "stimulus_strength": {
          "type": "number",
          "description": "Strength of the stimulus (affects detection priority).",
          "default": 1.0
        }
      },
      "additionalProperties": false,
      "required": ["actor_label", "operation"]
    }
  },
  {
    "name": "aisupport.debug_ai",
    "description": "Enable/configure AI debugging visualization for actors. Shows perception cones, pathfinding, current BT node, EQS results, blackboard values, and more. Uses the AI debugger (activated with ' key in-game).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor_label": {
          "type": "string",
          "description": "AI actor to debug.",
          "default": ""
        },
        "debug_categories": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": ["perception", "behavior_tree", "eqs", "pathfinding", "blackboard", "navmesh", "abilities"]
          },
          "description": "Which debug categories to enable.",
          "default": ["perception", "behavior_tree"]
        },
        "enable": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== ENVIRONMENT QUERY EDITOR === (API: Plugins/EnvironmentQueryEditor)  Editor-side EQS template authoring. FEnvironmentQueryEditorModule, UEnvironmentQueryGraphNode, UEnvironmentQueryGraphNode_Test, UEnvironmentQueryGraphNode_Option. Provides the visual graph editor for EQS queries  adding generators, tests, and configuring scoring."
  },
  {
    "name": "eqseditor.create_query",
    "description": "Create a new Environment Query System (EQS) query template asset. EQS queries evaluate spatial positions (generated by Generators) against Tests (distance, trace, dot product, etc.) to find optimal locations for AI behavior (cover, flanking, patrol, etc.).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Path for the new EQS query asset (e.g. /Game/AI/EQS/FindCoverQuery)."
        },
        "query_name": {
          "type": "string",
          "description": "Name for the query.",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "eqseditor.add_generator",
    "description": "Add a Generator node to an EQS query. Generators produce candidate items (locations, actors) for evaluation. Common generators: SimpleGrid (grid of points), OnCircle (ring around querier), ActorsOfClass (all actors of type), Donut, PathingGrid, CurrentLocation.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "query_path": {
          "type": "string",
          "description": "EQS query asset path."
        },
        "generator_class": {
          "type": "string",
          "enum": ["SimpleGrid", "OnCircle", "ActorsOfClass", "Donut", "PathingGrid", "CurrentLocation", "Composite", "PerceptionBased"],
          "description": "Generator class to add."
        },
        "settings": {
          "type": "object",
          "properties": {
            "search_radius": { "type": "number", "description": "Search radius in cm.", "default": 1000 },
            "space_between": { "type": "number", "description": "Grid/point spacing in cm.", "default": 200 },
            "search_center": { "type": "string", "description": "Context for center point.", "default": "Querier" },
            "actor_class": { "type": "string", "description": "For ActorsOfClass generator." },
            "number_of_items": { "type": "integer", "description": "For OnCircle/Donut generators." }
          },
          "additionalProperties": true
        }
      },
      "additionalProperties": false,
      "required": ["query_path", "generator_class"]
    }
  },
  {
    "name": "eqseditor.add_test",
    "description": "Add a Test node to a Generator in an EQS query. Tests score or filter generated items. Common tests: Distance (to context), Trace (line of sight), Dot (direction check), PathExists (reachability), Overlap (collision), GameplayTags, Random. Each test has a scoring function and optional filter mode.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "query_path": {
          "type": "string",
          "description": "EQS query asset path."
        },
        "generator_index": {
          "type": "integer",
          "description": "Index of the generator to add the test to.",
          "default": 0
        },
        "test_class": {
          "type": "string",
          "enum": ["Distance", "Trace", "Dot", "PathExists", "Overlap", "GameplayTags", "Random", "Project"],
          "description": "Test class to add."
        },
        "test_purpose": {
          "type": "string",
          "enum": ["score_only", "filter_only", "filter_and_score"],
          "default": "filter_and_score"
        },
        "context": {
          "type": "string",
          "description": "Context for the test (e.g. 'Querier', 'EnvQueryContext_Player').",
          "default": "Querier"
        },
        "scoring_equation": {
          "type": "string",
          "enum": ["linear", "inverse_linear", "square", "constant"],
          "default": "linear"
        },
        "weight": {
          "type": "number",
          "default": 1.0
        }
      },
      "additionalProperties": false,
      "required": ["query_path", "test_class"]
    }
  },
  {
    "name": "eqseditor.configure_test",
    "description": "Configure detailed settings on an existing EQS test. Set distance thresholds, trace channels, dot product reference directions, filter ranges, scoring curves, and clamping values.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "query_path": {
          "type": "string",
          "description": "EQS query asset path."
        },
        "generator_index": {
          "type": "integer",
          "default": 0
        },
        "test_index": {
          "type": "integer",
          "description": "Index of the test to configure.",
          "default": 0
        },
        "settings": {
          "type": "object",
          "properties": {
            "filter_min": { "type": "number" },
            "filter_max": { "type": "number" },
            "clamp_min": { "type": "number" },
            "clamp_max": { "type": "number" },
            "trace_channel": { "type": "string" },
            "trace_from_context": { "type": "string" },
            "reference_direction": { "type": "string" },
            "prefer_higher_values": { "type": "boolean", "default": true }
          },
          "additionalProperties": true
        }
      },
      "additionalProperties": false,
      "required": ["query_path", "settings"]
    }
  },

  {
    "_comment": "=== HTN PLANNER === (API: Plugins/HTNPlanner)  Hierarchical Task Network planning for AI. Alternative to BehaviorTrees  decomposes high-level tasks into ordered primitive actions based on world state. UHTNComponent, UHTNPlan, UHTNTask_Compound, UHTNTask_Primitive, UHTNDecorator, UHTNService. More expressive than BT for planning sequences of actions."
  },
  {
    "name": "htnplanner.create_htn_asset",
    "description": "Create a new HTN (Hierarchical Task Network) asset. HTN is an alternative to BehaviorTree for AI decision-making. Instead of reactive selection, HTN decomposes a root compound task into an ordered plan of primitive tasks based on current world state. Better for AI that needs to reason about sequences of actions.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": {
          "type": "string",
          "description": "Path for the new HTN asset (e.g. /Game/AI/HTN/CombatHTN)."
        },
        "root_task_name": {
          "type": "string",
          "description": "Name for the root compound task.",
          "default": "Root"
        }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "htnplanner.add_compound_task",
    "description": "Add a Compound Task to an HTN. Compound tasks decompose into methods  ordered sequences of sub-tasks (compound or primitive). Each method has preconditions checked against world state. The planner picks the first method whose preconditions are satisfied.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "htn_path": {
          "type": "string",
          "description": "HTN asset path."
        },
        "task_name": {
          "type": "string",
          "description": "Name for the compound task."
        },
        "parent_task": {
          "type": "string",
          "description": "Parent task to attach to (empty for root level).",
          "default": ""
        },
        "methods": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "preconditions": { "type": "array", "items": { "type": "string" }, "default": [] }
            }
          },
          "description": "Methods (decomposition options) for this compound task.",
          "default": []
        }
      },
      "additionalProperties": false,
      "required": ["htn_path", "task_name"]
    }
  },
  {
    "name": "htnplanner.add_primitive_task",
    "description": "Add a Primitive Task to an HTN method. Primitive tasks are leaf actions executed by the AI (move to, attack, wait, play animation, etc.). They have preconditions, effects (expected world state changes), and an operator (the actual execution logic, often a BT task or custom class).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "htn_path": {
          "type": "string",
          "description": "HTN asset path."
        },
        "task_name": {
          "type": "string",
          "description": "Primitive task name."
        },
        "method_name": {
          "type": "string",
          "description": "Method to add this task to."
        },
        "task_class": {
          "type": "string",
          "description": "Task operator class (e.g. 'HTNTask_MoveTo', 'HTNTask_Wait', 'HTNTask_PlayMontage').",
          "default": ""
        },
        "preconditions": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Blackboard key conditions that must be true.",
          "default": []
        },
        "effects": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Expected world state changes after execution.",
          "default": []
        }
      },
      "additionalProperties": false,
      "required": ["htn_path", "task_name", "method_name"]
    }
  },
  {
    "name": "htnplanner.configure_planning",
    "description": "Configure HTN planning parameters on an AI controller's HTN component. Settings: replan conditions, plan execution mode (sequential/parallel), max planning depth, planning timeout, world state source (blackboard keys).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "AI Controller or Character Blueprint path."
        },
        "htn_asset": {
          "type": "string",
          "description": "HTN asset to use for planning."
        },
        "replan_on_blackboard_change": {
          "type": "boolean",
          "description": "Automatically replan when blackboard values change.",
          "default": true
        },
        "max_plan_depth": {
          "type": "integer",
          "description": "Maximum task decomposition depth.",
          "default": 10
        },
        "planning_timeout": {
          "type": "number",
          "description": "Max time for planning in seconds.",
          "default": 0.1
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "htn_asset"]
    }
  },

  {
    "_comment": "=== LEARNING AGENTS === (API: Plugins/LearningAgents)  Machine learning for game AI. ULearningAgentsManager orchestrates training/inference for groups of agents. ULearningAgentsTrainer runs training loops. ULearningAgentsPolicy and ULearningAgentsInteractor define observation/action spaces. Supports reinforcement learning, imitation learning, and neural network policies for NPC behavior."
  },
  {
    "name": "learningagents.create_manager",
    "description": "Create a LearningAgents Manager component on an actor. The Manager orchestrates ML-driven AI agents, handling observation gathering, action execution, reward computation, and training coordination. This is the entry point for using UE5's built-in machine learning AI system.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Actor Blueprint to add the manager to."
        },
        "manager_name": {
          "type": "string",
          "default": "LearningAgentsManager"
        },
        "max_agents": {
          "type": "integer",
          "description": "Maximum number of agents this manager handles simultaneously.",
          "default": 64
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },
  {
    "name": "learningagents.configure_interactor",
    "description": "Configure the LearningAgents Interactor  defines the observation and action spaces for ML agents. Observations are what the agent perceives (distances, angles, health, nearby actors). Actions are what the agent can do (move direction, attack, jump). Both use schema objects (Float, Vector, Enum, Bool, etc.).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Actor Blueprint with the learning agents manager."
        },
        "observations": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string", "description": "Observation name." },
              "type": { "type": "string", "enum": ["float", "vector", "rotation", "bool", "enum", "struct"], "default": "float" },
              "size": { "type": "integer", "description": "Array size for multi-element observations.", "default": 1 }
            }
          },
          "description": "Observation space definition.",
          "default": []
        },
        "actions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string", "description": "Action name." },
              "type": { "type": "string", "enum": ["continuous", "discrete", "bool"], "default": "continuous" },
              "num_bins": { "type": "integer", "description": "Number of discrete bins (for discrete actions).", "default": 5 }
            }
          },
          "description": "Action space definition.",
          "default": []
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },
  {
    "name": "learningagents.configure_trainer",
    "description": "Configure the LearningAgents Trainer  sets up training parameters for ML agents. Supports reinforcement learning (reward-based) and imitation learning (demonstration-based). Configures learning rate, batch size, training iterations, discount factor, and network architecture.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Actor Blueprint with the learning agents manager."
        },
        "training_mode": {
          "type": "string",
          "enum": ["reinforcement", "imitation"],
          "default": "reinforcement"
        },
        "learning_rate": {
          "type": "number",
          "default": 0.001
        },
        "discount_factor": {
          "type": "number",
          "description": "Reward discount factor (gamma) for RL.",
          "default": 0.99
        },
        "batch_size": {
          "type": "integer",
          "default": 128
        },
        "training_iterations": {
          "type": "integer",
          "description": "Number of training iterations per episode.",
          "default": 1000
        },
        "hidden_layer_sizes": {
          "type": "array",
          "items": { "type": "integer" },
          "description": "Neural network hidden layer sizes.",
          "default": [128, 64]
        },
        "save_path": {
          "type": "string",
          "description": "Path to save trained model snapshots.",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },
  {
    "name": "learningagents.manage_training",
    "description": "Control training sessions: start training, stop, resume, load a saved model, or export a trained policy for inference-only use. Training runs in-editor with PIE (Play In Editor) sessions.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": {
          "type": "string",
          "enum": ["start_training", "stop_training", "resume_training", "load_model", "export_policy", "get_training_stats"],
          "description": "Training management operation."
        },
        "model_path": {
          "type": "string",
          "description": "Model file path (for load/export operations).",
          "default": ""
        },
        "episodes": {
          "type": "integer",
          "description": "Number of episodes to train.",
          "default": 100
        }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },

  {
    "_comment": "=== MASS AI === (API: Plugins/MassAI)  AI behaviors for Mass Entity Framework (ECS). UMassStateTreeProcessor, UMassNavigationProcessor, UMassSteeringProcessor, UMassSmartObjectProcessor, UMassLookAtProcessor. Enables BehaviorTree/StateTree-driven AI at scale using Mass Entity fragments and processors. Used for large NPC crowds and swarms."
  },
  {
    "name": "massai.configure_mass_ai",
    "description": "Configure MassAI processors on a Mass Entity Config. MassAI enables AI behavior (navigation, steering, state trees, smart objects, look-at) on Mass entities for high-performance crowd/swarm AI. Each processor handles a specific aspect of AI behavior using ECS fragments.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "entity_config_path": {
          "type": "string",
          "description": "MassEntityConfig asset path."
        },
        "processors": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": ["navigation", "steering", "state_tree", "smart_object", "look_at", "avoidance", "zone_graph_navigation", "signal"]
          },
          "description": "MassAI processors to enable.",
          "default": ["navigation", "steering", "state_tree"]
        },
        "state_tree_asset": {
          "type": "string",
          "description": "StateTree asset for MassStateTreeProcessor.",
          "default": ""
        },
        "navigation_mode": {
          "type": "string",
          "enum": ["navmesh", "zone_graph", "none"],
          "description": "Navigation system to use.",
          "default": "navmesh"
        }
      },
      "additionalProperties": false,
      "required": ["entity_config_path"]
    }
  },
  {
    "name": "massai.add_mass_spawner",
    "description": "Add or configure a MassSpawner actor in the level. MassSpawners spawn Mass entities at runtime based on MassEntityConfig templates. Configure spawn count, area, density, and spawning patterns for crowd generation.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "spawner_label": {
          "type": "string",
          "description": "Label for the MassSpawner actor.",
          "default": "MassSpawner"
        },
        "entity_config_path": {
          "type": "string",
          "description": "MassEntityConfig to spawn."
        },
        "spawn_count": {
          "type": "integer",
          "description": "Number of entities to spawn.",
          "default": 100
        },
        "spawn_location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "default": { "x": 0, "y": 0, "z": 0 }
        },
        "spawn_radius": {
          "type": "number",
          "description": "Radius of spawn area in cm.",
          "default": 2000
        }
      },
      "additionalProperties": false,
      "required": ["entity_config_path"]
    }
  },
  {
    "name": "massai.inspect_mass_entities",
    "description": "Inspect running Mass entities  query processor stats, entity counts, fragment data, and performance metrics. Useful for debugging MassAI behavior and optimizing ECS performance.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "query_type": {
          "type": "string",
          "enum": ["entity_count", "processor_stats", "archetype_info", "fragment_data", "performance"],
          "default": "entity_count"
        },
        "filter_processor": {
          "type": "string",
          "description": "Filter by processor name.",
          "default": ""
        },
        "max_results": {
          "type": "integer",
          "default": 50
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== MASS CROWD === (API: Plugins/MassCrowd)  Crowd simulation on Mass Entity Framework. UMassCrowdRepresentationProcessor (LOD visualization), UMassCrowdLaneMovementProcessor (lane-based movement on ZoneGraph), UMassCrowdServerRepresentationLODProcessor. Extends MassAI for pedestrian/vehicle crowd behavior along ZoneGraph lanes."
  },
  {
    "name": "masscrowd.configure_crowd",
    "description": "Configure MassCrowd settings for pedestrian/vehicle crowd simulation along ZoneGraph lanes. MassCrowd extends MassAI with lane-based movement, LOD representation, and crowd-specific avoidance. Entities flow along ZoneGraph lanes with proper density, speed, and visual LOD management.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "entity_config_path": {
          "type": "string",
          "description": "MassEntityConfig asset path for crowd agents."
        },
        "movement_style": {
          "type": "string",
          "enum": ["pedestrian", "vehicle", "custom"],
          "default": "pedestrian"
        },
        "lane_speed_multiplier": {
          "type": "number",
          "description": "Speed multiplier for lane movement.",
          "default": 1.0
        },
        "representation_lod": {
          "type": "object",
          "properties": {
            "high_lod_distance": { "type": "number", "default": 1500 },
            "medium_lod_distance": { "type": "number", "default": 5000 },
            "low_lod_distance": { "type": "number", "default": 15000 }
          },
          "description": "LOD distance thresholds for crowd visualization."
        },
        "avoidance_enabled": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["entity_config_path"]
    }
  },
  {
    "name": "masscrowd.assign_crowd_lanes",
    "description": "Assign crowd entities to ZoneGraph lanes for lane-based movement. Specify which ZoneGraph lanes the crowd should use, lane filtering by tags, and lane occupation density limits.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "entity_config_path": {
          "type": "string",
          "description": "MassEntityConfig for crowd agents."
        },
        "zone_graph_path": {
          "type": "string",
          "description": "ZoneGraph data asset or ZoneGraph actor label.",
          "default": ""
        },
        "lane_filter_tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "GameplayTags to filter lanes (e.g. ['Zone.Lane.Sidewalk', 'Zone.Lane.Road']).",
          "default": []
        },
        "max_density_per_lane": {
          "type": "number",
          "description": "Maximum agents per meter of lane.",
          "default": 1.0
        }
      },
      "additionalProperties": false,
      "required": ["entity_config_path"]
    }
  },

  {
    "_comment": "=== ML ADAPTER === (API: Plugins/MLAdapter)  Machine learning adapter for external ML frameworks. UMLAdapterManager connects UE to external Python ML processes (TensorFlow, PyTorch, etc.) via RPC. Sensors gather game observations, Actuators execute actions. Enables training RL agents from external scripts against the running game."
  },
  {
    "name": "mladapter.configure_adapter",
    "description": "Configure the ML Adapter Manager for connecting UE to external ML frameworks (TensorFlow, PyTorch). The adapter exposes game state as observations via Sensors and accepts actions via Actuators over RPC. External Python scripts can then train RL agents against the running game.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "rpc_port": {
          "type": "integer",
          "description": "RPC server port for ML framework connection.",
          "default": 35353
        },
        "server_address": {
          "type": "string",
          "description": "RPC server address.",
          "default": "localhost"
        },
        "auto_start": {
          "type": "boolean",
          "description": "Automatically start the RPC server on game launch.",
          "default": true
        },
        "tick_rate": {
          "type": "number",
          "description": "Decision-making tick rate (Hz).",
          "default": 20.0
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "mladapter.add_sensor",
    "description": "Add an ML Adapter Sensor to an agent. Sensors gather observations from the game world and send them to the external ML framework. Available sensors: Camera (visual), RayCast (spatial), Attribute (gameplay values), Input (current input), Transform, and custom.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Agent Blueprint to add the sensor to."
        },
        "sensor_type": {
          "type": "string",
          "enum": ["camera", "raycast", "attribute", "input", "transform", "custom"],
          "description": "Type of sensor."
        },
        "sensor_name": {
          "type": "string",
          "description": "Unique name for this sensor.",
          "default": ""
        },
        "settings": {
          "type": "object",
          "properties": {
            "resolution_x": { "type": "integer", "description": "Camera sensor width.", "default": 84 },
            "resolution_y": { "type": "integer", "description": "Camera sensor height.", "default": 84 },
            "ray_count": { "type": "integer", "description": "Number of rays for raycast sensor.", "default": 36 },
            "ray_length": { "type": "number", "description": "Ray length in cm.", "default": 5000 },
            "attributes": { "type": "array", "items": { "type": "string" }, "description": "Property names for attribute sensor." }
          },
          "additionalProperties": true
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "sensor_type"]
    }
  },
  {
    "name": "mladapter.add_actuator",
    "description": "Add an ML Adapter Actuator to an agent. Actuators receive actions from the external ML framework and execute them in-game. Available actuators: InputAction (simulates input), Movement, Custom function calls.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Agent Blueprint to add the actuator to."
        },
        "actuator_type": {
          "type": "string",
          "enum": ["input_action", "movement", "custom"],
          "description": "Type of actuator."
        },
        "actuator_name": {
          "type": "string",
          "default": ""
        },
        "input_actions": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Input action names this actuator can trigger (for input_action type).",
          "default": []
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "actuator_type"]
    }
  },

  {
    "_comment": "=== ZONE GRAPH === (API: Plugins/ZoneGraph)  Lane-based spatial graph for AI navigation and crowd flow. UZoneGraphSubsystem manages zones. UZoneShapeComponent defines zone shapes (splines with lane widths). FZoneGraphData stores compiled graph data. Used by MassCrowd and MassAI for lane-based pathfinding instead of NavMesh."
  },
  {
    "name": "zonegraph.create_zone_shape",
    "description": "Create a ZoneShape actor in the level. ZoneShapes define lanes (paths) that AI agents follow using ZoneGraph-based navigation. Each shape is a spline with configurable lane count, width, and tags. ZoneGraph is the lane-based alternative to NavMesh, used by MassAI and MassCrowd.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor_label": {
          "type": "string",
          "description": "Label for the ZoneShape actor.",
          "default": "ZoneShape"
        },
        "shape_type": {
          "type": "string",
          "enum": ["spline", "polygon"],
          "description": "'spline' for path-like lanes, 'polygon' for area zones.",
          "default": "spline"
        },
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "default": { "x": 0, "y": 0, "z": 0 }
        },
        "lane_count": {
          "type": "integer",
          "description": "Number of parallel lanes in this shape.",
          "default": 1
        },
        "lane_width": {
          "type": "number",
          "description": "Width of each lane in cm.",
          "default": 200
        },
        "lane_tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "GameplayTags for lane filtering (e.g. 'Zone.Lane.Sidewalk').",
          "default": []
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "zonegraph.build_zone_graph",
    "description": "Build/rebuild the ZoneGraph data from all ZoneShape actors in the level. Compiles zone shapes into an optimized graph structure for runtime pathfinding. Must be rebuilt after modifying zone shapes.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "rebuild_all": {
          "type": "boolean",
          "description": "Rebuild all zone data. If false, only rebuild dirty zones.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "zonegraph.query_lanes",
    "description": "Query ZoneGraph lanes near a location. Returns matching lanes with their tags, lengths, connected lanes, and intersection points. Used for debugging zone graph connectivity and verifying lane setups.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "description": "Query location."
        },
        "search_radius": {
          "type": "number",
          "description": "Search radius in cm.",
          "default": 2000
        },
        "tag_filter": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Only return lanes matching these tags.",
          "default": []
        },
        "max_results": {
          "type": "integer",
          "default": 20
        }
      },
      "additionalProperties": false,
      "required": ["location"]
    }
  },

  {
    "_comment": "=== ZONE GRAPH ANNOTATIONS === (API: Plugins/ZoneGraphAnnotations)  Runtime annotations on ZoneGraph lanes. UZoneGraphAnnotationSubsystem manages dynamic lane metadata at runtime. FZoneGraphTag, UZoneGraphAnnotationComponent. Used to mark lanes as blocked, dangerous, congested, or reserved. MassAI/MassCrowd agents avoid or prefer lanes based on annotations."
  },
  {
    "name": "zonegraphannotations.add_annotation",
    "description": "Add a runtime annotation to ZoneGraph lanes. Annotations mark lanes with dynamic metadata: danger zones, blocked paths, congestion levels, reserved areas. MassAI and MassCrowd agents use annotations to avoid or prefer specific lanes during navigation.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "annotation_type": {
          "type": "string",
          "enum": ["blocked", "danger", "congestion", "reserved", "custom"],
          "description": "Type of annotation."
        },
        "lane_location": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "description": "Location to find nearby lanes to annotate."
        },
        "radius": {
          "type": "number",
          "description": "Radius of effect in cm.",
          "default": 500
        },
        "annotation_tag": {
          "type": "string",
          "description": "GameplayTag for the annotation.",
          "default": ""
        },
        "duration": {
          "type": "number",
          "description": "Duration in seconds. 0 for permanent.",
          "default": 0
        },
        "weight": {
          "type": "number",
          "description": "Avoidance weight (higher = stronger avoidance).",
          "default": 1.0
        }
      },
      "additionalProperties": false,
      "required": ["annotation_type", "lane_location"]
    }
  },
  {
    "name": "zonegraphannotations.clear_annotations",
    "description": "Clear annotations from ZoneGraph lanes. Remove specific annotation types or all annotations within an area.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "clear_type": {
          "type": "string",
          "enum": ["all", "by_tag", "by_area", "by_type"],
          "description": "How to select annotations to clear."
        },
        "annotation_tag": {
          "type": "string",
          "description": "Tag filter (for by_tag mode).",
          "default": ""
        },
        "area_center": {
          "type": "object",
          "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } },
          "description": "Center of area (for by_area mode)."
        },
        "area_radius": {
          "type": "number",
          "description": "Radius of area to clear (for by_area mode).",
          "default": 1000
        },
        "annotation_type": {
          "type": "string",
          "enum": ["blocked", "danger", "congestion", "reserved", "custom"],
          "description": "Annotation type filter (for by_type mode).",
          "default": ""
        }
      },
      "additionalProperties": false,
      "required": ["clear_type"]
    }
  },

  {
    "_comment": "=== ANIMATION LOCOMOTION LIBRARY === (API: Plugins/AnimationLocomotionLibrary)  Blueprint function library for advanced locomotion animation: distance matching, stride warping integration, orientation warping helpers, acceleration-based animation selection. UAnimDistanceMatchingLibrary, UAnimCharacterMovementLibrary. Provides BP-callable functions that complement AnimWarping and MotionTrajectory features."
  },
  {
    "name": "animlocomotion.distance_matching",
    "description": "Configure Distance Matching on an animation sequence. Distance matching advances or plays back animation based on distance traveled rather than time, preventing foot sliding during starts, stops, and pivots. Uses UAnimDistanceMatchingLibrary functions: AdvanceTimeByDistanceMatching, DistanceMatchToTarget.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Animation Blueprint asset path."
        },
        "anim_sequence_path": {
          "type": "string",
          "description": "AnimSequence to apply distance matching to."
        },
        "matching_mode": {
          "type": "string",
          "enum": ["advance_by_distance", "match_to_target", "distance_to_stop"],
          "description": "'advance_by_distance' plays based on distance traveled, 'match_to_target' syncs to distance-to-target, 'distance_to_stop' for stop animations.",
          "default": "advance_by_distance"
        },
        "distance_curve_name": {
          "type": "string",
          "description": "Name of the distance curve in the anim sequence (must be authored via anim modifier or manually).",
          "default": "DistanceCurve"
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path", "anim_sequence_path"]
    }
  },
  {
    "name": "animlocomotion.predict_ground_movement",
    "description": "Configure predicted ground movement trajectory for locomotion animation selection. Uses UAnimCharacterMovementLibrary to predict future movement based on current velocity, acceleration, and input. The prediction feeds into Motion Matching, BlendSpaces, and distance matching.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": {
          "type": "string",
          "description": "Character Blueprint path."
        },
        "prediction_time": {
          "type": "number",
          "description": "How far ahead to predict (seconds).",
          "default": 0.5
        },
        "use_acceleration": {
          "type": "boolean",
          "description": "Factor in acceleration for prediction.",
          "default": true
        },
        "braking_friction": {
          "type": "number",
          "description": "Braking friction factor for stop prediction.",
          "default": 0.5
        }
      },
      "additionalProperties": false,
      "required": ["blueprint_path"]
    }
  },
  {
    "name": "animlocomotion.setup_start_stop_system",
    "description": "Set up a complete start/stop animation system using distance matching and stride warping. Configures: distance-matched start animations (play N cm of travel), distance-matched stop animations (sync to braking distance), stride warping for speed adaptation, and pivot animations.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_blueprint_path": {
          "type": "string",
          "description": "Animation Blueprint to set up."
        },
        "start_anim": {
          "type": "string",
          "description": "Start animation sequence path.",
          "default": ""
        },
        "stop_anim": {
          "type": "string",
          "description": "Stop animation sequence path.",
          "default": ""
        },
        "pivot_anim": {
          "type": "string",
          "description": "Pivot/direction change animation path.",
          "default": ""
        },
        "cycle_anim": {
          "type": "string",
          "description": "Locomotion cycle animation path.",
          "default": ""
        },
        "enable_stride_warping": {
          "type": "boolean",
          "description": "Apply stride warping to cycle animation for speed adaptation.",
          "default": true
        },
        "enable_orientation_warping": {
          "type": "boolean",
          "description": "Apply orientation warping for directional blending.",
          "default": true
        }
      },
      "additionalProperties": false,
      "required": ["anim_blueprint_path"]
    }
  },

  {
    "_comment": "=== CHAOS CLOTH GENERATOR === (API: Plugins/ChaosClothGenerator)  Procedural cloth asset generation pipeline. FChaosClothGenerator creates Chaos Cloth simulation assets from skeletal meshes. Configures cloth LODs, paint maps, constraint setup, and cloth sim parameters for Chaos physics cloth."
  },
  {
    "name": "chaosclothgen.generate_cloth_asset",
    "description": "Generate a Chaos Cloth asset from a skeletal mesh section. Selects a mesh section as a cloth simulation panel, generates the cloth asset with initial simulation parameters, and assigns it to the skeletal mesh component. This is the starting point for Chaos cloth setup.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skeletal_mesh_path": { "type": "string", "description": "SkeletalMesh asset path." },
        "section_index": { "type": "integer", "description": "Mesh section index to convert to cloth.", "default": 0 },
        "cloth_asset_name": { "type": "string", "description": "Name for the generated cloth asset.", "default": "" },
        "lod_index": { "type": "integer", "description": "LOD level to generate cloth for.", "default": 0 }
      },
      "additionalProperties": false,
      "required": ["skeletal_mesh_path"]
    }
  },
  {
    "name": "chaosclothgen.configure_cloth_sim",
    "description": "Configure Chaos Cloth simulation parameters: mass, stiffness, damping, gravity scale, air resistance, backstop, collision thickness, self-collision, and solver iterations. Fine-tunes cloth behavior for the target aesthetic (flowy cape, stiff armor cloth, etc.).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skeletal_mesh_path": { "type": "string", "description": "SkeletalMesh with cloth asset." },
        "cloth_index": { "type": "integer", "default": 0 },
        "mass": { "type": "number", "description": "Cloth particle mass.", "default": 1.0 },
        "stiffness": { "type": "number", "description": "Structural stiffness (0-1).", "default": 0.8 },
        "bending_stiffness": { "type": "number", "description": "Bending resistance (0-1).", "default": 0.5 },
        "damping": { "type": "number", "description": "Velocity damping (0-1).", "default": 0.01 },
        "gravity_scale": { "type": "number", "default": 1.0 },
        "drag_coefficient": { "type": "number", "description": "Air drag.", "default": 0.07 },
        "lift_coefficient": { "type": "number", "description": "Air lift.", "default": 0.035 },
        "collision_thickness": { "type": "number", "description": "Collision shell thickness in cm.", "default": 1.0 },
        "self_collision": { "type": "boolean", "default": false },
        "solver_iterations": { "type": "integer", "description": "Constraint solver iterations.", "default": 8 }
      },
      "additionalProperties": false,
      "required": ["skeletal_mesh_path"]
    }
  },
  {
    "name": "chaosclothgen.paint_cloth_weights",
    "description": "Set cloth paint weights for constraint and simulation masking. Paints max distance (how far vertices can move from bind pose), backstop distance/radius (prevents cloth from penetrating the body), and anim-drive multipliers. Values range 0-1 or 0-max distance in cm.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skeletal_mesh_path": { "type": "string" },
        "cloth_index": { "type": "integer", "default": 0 },
        "paint_type": { "type": "string", "enum": ["max_distance", "backstop_distance", "backstop_radius", "anim_drive_stiffness", "anim_drive_damping"], "default": "max_distance" },
        "vertex_weights": { "type": "object", "description": "Map of vertex_indexweight_value for targeted painting.", "additionalProperties": { "type": "number" }, "default": {} },
        "default_value": { "type": "number", "description": "Default value to apply to all unpainted vertices.", "default": 100.0 }
      },
      "additionalProperties": false,
      "required": ["skeletal_mesh_path"]
    }
  },

  {
    "_comment": "=== CHAOS FLESH GENERATOR === (API: Plugins/ChaosFleshGenerator)  Procedural deformable body/flesh simulation. Creates tetrahedral mesh assets for soft-body deformation (muscles, fat jiggle, organs). FChaosFleshGenerator handles tet-mesh generation from surface meshes. Used with Chaos Destruction for realistic body deformation."
  },
  {
    "name": "chaosflesh.create_flesh_asset",
    "description": "Create a Chaos Flesh (deformable body) asset from a skeletal or static mesh. Generates a tetrahedral mesh internally for volumetric soft-body simulation. Used for realistic muscle/fat jiggle, organ deformation, and soft-body physics.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source_mesh_path": { "type": "string", "description": "Source mesh asset path (SkeletalMesh or StaticMesh)." },
        "asset_path": { "type": "string", "description": "Output path for the flesh asset (e.g. /Game/Physics/FleshBody)." },
        "tet_mesh_resolution": { "type": "integer", "description": "Tetrahedral mesh resolution (higher = more detail but slower).", "default": 10 },
        "surface_to_tet_binding": { "type": "boolean", "description": "Bind surface mesh vertices to tet mesh for deformation.", "default": true }
      },
      "additionalProperties": false,
      "required": ["source_mesh_path", "asset_path"]
    }
  },
  {
    "name": "chaosflesh.configure_deformation",
    "description": "Configure Chaos Flesh deformation properties: material stiffness, damping, incompressibility, density. Controls how the soft body responds to forces  stiffer for muscle, softer for fat/jelly.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "flesh_asset_path": { "type": "string", "description": "Flesh asset path." },
        "youngs_modulus": { "type": "number", "description": "Material stiffness (Pa). ~1000 for soft tissue, ~10000 for muscle.", "default": 5000 },
        "poissons_ratio": { "type": "number", "description": "Incompressibility (0-0.5). 0.5 = perfectly incompressible.", "default": 0.45 },
        "density": { "type": "number", "description": "Material density kg/m.", "default": 1000 },
        "damping": { "type": "number", "description": "Velocity damping.", "default": 0.01 }
      },
      "additionalProperties": false,
      "required": ["flesh_asset_path"]
    }
  },

  {
    "_comment": "=== COMMON UI EDITOR === (API: Plugins/CommonUIEditor)  Editor-side utilities for the CommonUI plugin. Widget style browser, input-action data table editors, CommonUI asset factories, CommonUI-specific Slate widget editors. Extends the CommonUI runtime with editing tools for managing platform-agnostic UI."
  },
  {
    "name": "commonuieditor.create_widget_style",
    "description": "Create a CommonUI Widget Style DataAsset (UCommonButtonStyle, UCommonTextStyle, UCommonBorderStyle). Widget styles define reusable look-and-feel for CommonUI widgets across all platforms.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string", "description": "Path for the new style asset (e.g. /Game/UI/Styles/PrimaryButtonStyle)." },
        "style_type": { "type": "string", "enum": ["button_style", "text_style", "border_style"], "description": "Type of CommonUI style to create." },
        "base_style": { "type": "string", "description": "Parent style asset to inherit from.", "default": "" }
      },
      "additionalProperties": false,
      "required": ["asset_path", "style_type"]
    }
  },
  {
    "name": "commonuieditor.configure_input_action_data",
    "description": "Create or modify CommonUI Input Action Data entries. These define platform-agnostic input actions with per-platform key images, hold durations, and display names for consistent UI input prompts across gamepad/keyboard/touch.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data_table_path": { "type": "string", "description": "CommonUI Input Action DataTable asset path." },
        "action_name": { "type": "string", "description": "Row name / action identifier." },
        "display_name": { "type": "string", "description": "Localizable display name.", "default": "" },
        "keyboard_key": { "type": "string", "description": "Default keyboard key name.", "default": "" },
        "gamepad_key": { "type": "string", "description": "Default gamepad key name.", "default": "" },
        "hold_duration": { "type": "number", "description": "Hold input duration in seconds (0 = press).", "default": 0 }
      },
      "additionalProperties": false,
      "required": ["data_table_path", "action_name"]
    }
  },

  {
    "_comment": "=== FULL BODY IK === (API: Plugins/FullBodyIK)  Full-Body IK solver plugin (FBIKSolver). Whole-body pose solving with multiple effectors  position/rotation targets on any bone. FFullBodyIK, FRigUnit_FullBodyIK, FBIKConstraint. Used in IKRig for full-body retargeting and procedural animation."
  },
  {
    "name": "fullbodyik.configure_solver",
    "description": "Add or configure a Full Body IK solver in an IKRig asset. FBIK solves the entire skeleton simultaneously (unlike chain IK which solves per-limb). Configure solver iterations, precision, root behavior, and pull chain settings for whole-body procedural animation.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ikrig_path": { "type": "string", "description": "IKRig asset path." },
        "solver_iterations": { "type": "integer", "description": "Max solver iterations.", "default": 20 },
        "precision": { "type": "number", "description": "Convergence precision.", "default": 0.01 },
        "root_behavior": { "type": "string", "enum": ["free", "pinned", "pin_to_input"], "description": "How the root bone behaves during solving.", "default": "pin_to_input" },
        "pull_chain_alpha": { "type": "number", "description": "How much child effectors pull parent chains (0-1).", "default": 1.0 },
        "mass_multiplier": { "type": "number", "description": "Mass-based resistance to movement.", "default": 1.0 }
      },
      "additionalProperties": false,
      "required": ["ikrig_path"]
    }
  },
  {
    "name": "fullbodyik.add_effector",
    "description": "Add an FBIK effector to a bone. Effectors define target positions/rotations that the solver tries to reach. Multiple effectors drive the full-body solve  hands, feet, head, pelvis, etc.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ikrig_path": { "type": "string", "description": "IKRig asset path." },
        "bone_name": { "type": "string", "description": "Bone to attach the effector to." },
        "position_alpha": { "type": "number", "description": "Position solve strength (0-1).", "default": 1.0 },
        "rotation_alpha": { "type": "number", "description": "Rotation solve strength (0-1).", "default": 0.0 },
        "pull_chain_alpha": { "type": "number", "description": "Pull chain strength.", "default": 1.0 },
        "pin_rotation": { "type": "boolean", "description": "Pin the rotation to the target.", "default": false }
      },
      "additionalProperties": false,
      "required": ["ikrig_path", "bone_name"]
    }
  },
  {
    "name": "fullbodyik.set_bone_settings",
    "description": "Configure per-bone settings for the FBIK solver. Set stiffness, rotation limits, preferred angles, and excluded bones. Controls how individual bones respond during the full-body solve.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ikrig_path": { "type": "string", "description": "IKRig asset path." },
        "bone_name": { "type": "string", "description": "Bone to configure." },
        "rotation_stiffness": { "type": "number", "description": "Resistance to rotation change (0=free, 1=locked).", "default": 0.0 },
        "position_stiffness": { "type": "number", "description": "Resistance to position change.", "default": 0.0 },
        "use_rotation_limits": { "type": "boolean", "description": "Enable joint rotation limits.", "default": false },
        "excluded": { "type": "boolean", "description": "Exclude this bone from the solve.", "default": false }
      },
      "additionalProperties": false,
      "required": ["ikrig_path", "bone_name"]
    }
  },

  {
    "_comment": "=== GAME FEATURES === (API: Plugins/GameFeatures, Plugins/GameFeaturesEditor)  Modular Game Feature Plugin system. UGameFeaturesSubsystem manages feature loading/activation. UGameFeatureData defines actions (AddComponents, AddDataRegistry, AddWorldSystems). FGameFeaturePluginStateMachine handles state transitions. Enables modular gameplay  features can be activated per level/mode/DLC."
  },
  {
    "name": "gamefeatures.create_feature",
    "description": "Create a new Game Feature Plugin with a GameFeatureData asset. Game Features are modular gameplay modules that can be activated/deactivated at runtime  enabling modular content like game modes, DLC packs, or feature flags.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "feature_name": { "type": "string", "description": "Game Feature Plugin name (e.g. 'CombatFeature', 'MultiplayerMode')." },
        "base_path": { "type": "string", "description": "Base content path for the feature.", "default": "/Game/GameFeatures" },
        "initial_state": { "type": "string", "enum": ["installed", "registered", "loaded", "active"], "description": "Initial feature state.", "default": "active" }
      },
      "additionalProperties": false,
      "required": ["feature_name"]
    }
  },
  {
    "name": "gamefeatures.add_action",
    "description": "Add a Game Feature Action to a GameFeatureData asset. Actions define what happens when the feature activates: AddComponents (inject components onto actors), AddDataRegistry, AddWorldSystem, AddCheats, etc.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "feature_data_path": { "type": "string", "description": "GameFeatureData asset path." },
        "action_type": { "type": "string", "enum": ["add_components", "add_data_registry", "add_world_system", "add_cheats", "add_input_config", "add_widget", "custom"], "description": "Type of Game Feature Action." },
        "action_config": { "type": "object", "description": "Action-specific configuration.", "properties": {
          "component_class": { "type": "string", "description": "Component class to add (for add_components)." },
          "target_actor_class": { "type": "string", "description": "Actor class to add component to." },
          "data_registry_path": { "type": "string", "description": "DataRegistry asset (for add_data_registry)." }
        }, "additionalProperties": true }
      },
      "additionalProperties": false,
      "required": ["feature_data_path", "action_type"]
    }
  },
  {
    "name": "gamefeatures.manage_state",
    "description": "Activate, deactivate, load, or query Game Feature Plugin states. The state machine transitions: Installed  Registered  Loaded  Active. Features can be toggled at runtime for modular gameplay.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "feature_name": { "type": "string", "description": "Game Feature Plugin name or URL." },
        "operation": { "type": "string", "enum": ["activate", "deactivate", "load", "unload", "get_state", "list_all"], "description": "State management operation." }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },

  {
    "_comment": "=== GAMEPLAY ABILITIES EDITOR === (API: Plugins/GameplayAbilitiesEditor)  Editor tools for the Gameplay Ability System (GAS). SGameplayAttributeGraphPin, FGameplayAbilityBlueprintDetails, UGameplayCueBlueprintLibrary, Attribute/Effect/Cue asset editors. Extends gas.* tools with editor-specific GAS authoring."
  },
  {
    "name": "gaseditor.create_gameplay_cue",
    "description": "Create a Gameplay Cue Notify Blueprint. Gameplay Cues are the visual/audio response to GameplayEffects  particle effects, sounds, screen shakes triggered by GAS tag events (GameplayCue.Damage.Fire, etc.).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string", "description": "Path for the GameplayCue Blueprint (e.g. /Game/GAS/Cues/GC_DamageFire)." },
        "cue_tag": { "type": "string", "description": "GameplayCue tag (e.g. 'GameplayCue.Damage.Fire')." },
        "cue_type": { "type": "string", "enum": ["notify_static", "notify_actor", "notify_loop"], "description": "Cue notify type: static (one-shot), actor (spawns actor), loop (continuous).", "default": "notify_static" }
      },
      "additionalProperties": false,
      "required": ["asset_path", "cue_tag"]
    }
  },
  {
    "name": "gaseditor.configure_attribute_set",
    "description": "Configure a Gameplay Attribute Set  define attributes (Health, Mana, Damage) with default values, clamping, and replication settings. Attribute Sets hold the numeric data that GameplayEffects modify.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": { "type": "string", "description": "AttributeSet Blueprint or C++ class path." },
        "attributes": { "type": "array", "items": { "type": "object", "properties": {
          "name": { "type": "string", "description": "Attribute name (e.g. 'Health', 'MaxHealth')." },
          "default_value": { "type": "number", "default": 100 },
          "min_value": { "type": "number", "default": 0 },
          "max_value": { "type": "number", "default": 9999 },
          "replicated": { "type": "boolean", "default": true }
        }}, "description": "Attributes to add/configure." }
      },
      "additionalProperties": false,
      "required": ["blueprint_path", "attributes"]
    }
  },

  {
    "_comment": "=== GAMEPLAY BEHAVIORS === (API: Plugins/GameplayBehaviorsModule, Plugins/GameplayBehaviorsEditorModule)  Reusable AI behaviors triggered by SmartObjects. UGameplayBehaviorConfig defines behavior parameters. UGameplayBehavior_BehaviorTree wraps a BT as a behavior. UGameplayBehavior_AnimSequence plays an animation. Used with MassAI and SmartObjects for context-driven NPC actions (sitting, eating, talking)."
  },
  {
    "name": "gameplaybehaviors.create_config",
    "description": "Create a GameplayBehaviorConfig DataAsset. Behavior configs define reusable NPC actions triggered by SmartObjects  sit on a bench, eat at a table, operate a machine. Configs link to BehaviorTrees, AnimSequences, or custom behavior classes.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string", "description": "Path for the GameplayBehaviorConfig asset." },
        "behavior_type": { "type": "string", "enum": ["behavior_tree", "anim_sequence", "custom"], "description": "Type of behavior to configure.", "default": "behavior_tree" },
        "behavior_tree_path": { "type": "string", "description": "BehaviorTree asset (for behavior_tree type).", "default": "" },
        "anim_sequence_path": { "type": "string", "description": "AnimSequence asset (for anim_sequence type).", "default": "" },
        "custom_behavior_class": { "type": "string", "description": "C++ or Blueprint class (for custom type).", "default": "" }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "gameplaybehaviors.assign_to_smart_object",
    "description": "Assign a GameplayBehavior to a SmartObject slot definition. When an AI agent claims this SmartObject slot, the linked behavior executes. Multiple behaviors can be assigned to different slots on the same SmartObject.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "smart_object_definition_path": { "type": "string", "description": "SmartObjectDefinition asset path." },
        "slot_index": { "type": "integer", "description": "Slot index to assign the behavior to.", "default": 0 },
        "behavior_config_path": { "type": "string", "description": "GameplayBehaviorConfig asset path." },
        "required_tags": { "type": "array", "items": { "type": "string" }, "description": "GameplayTags the claiming agent must have.", "default": [] }
      },
      "additionalProperties": false,
      "required": ["smart_object_definition_path", "behavior_config_path"]
    }
  },

  {
    "_comment": "=== JSON SERIALIZATION === (API: Plugins/JsonSerialization)  UE JSON serialization utilities for Blueprint-accessible JSON read/write. FJsonObjectConverter, UJsonDeserializeLibrary, FJsonObjectWrapper. Serialize UStructs to/from JSON, parse JSON files, and work with JSON data in Blueprints."
  },
  {
    "name": "jsonserialization.serialize_struct",
    "description": "Serialize a UStruct/UObject to JSON string or file. Uses FJsonObjectConverter to convert any Blueprint-visible struct or object properties to JSON format. Useful for save systems, config export, and data interchange.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source_path": { "type": "string", "description": "Asset or object path (DataAsset, DataTable row, any UObject)." },
        "output_file": { "type": "string", "description": "Optional file path to write JSON to. If empty, returns JSON string.", "default": "" },
        "pretty_print": { "type": "boolean", "default": true },
        "skip_transient": { "type": "boolean", "description": "Skip transient properties.", "default": true }
      },
      "additionalProperties": false,
      "required": ["source_path"]
    }
  },
  {
    "name": "jsonserialization.deserialize_to_struct",
    "description": "Deserialize JSON data into a UStruct/UObject. Reads a JSON string or file and populates struct properties. Used for importing configuration, loading save data, or consuming external API responses.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "target_path": { "type": "string", "description": "Target asset to populate (DataAsset, any UObject)." },
        "json_file": { "type": "string", "description": "JSON file path to read from.", "default": "" },
        "json_string": { "type": "string", "description": "Inline JSON string (alternative to json_file).", "default": "" },
        "struct_type": { "type": "string", "description": "UStruct class name if creating new.", "default": "" }
      },
      "additionalProperties": false,
      "required": ["target_path"]
    }
  },

  {
    "_comment": "=== JWT === (API: Plugins/JWT)  JSON Web Token creation and validation for UE. FJwtToken, FJwtAlgorithm. Enables JWT-based authentication for online services, dedicated server validation, and secure token exchange in multiplayer games."
  },
  {
    "name": "jwt.manage_token",
    "description": "Create, validate, or inspect a JWT (JSON Web Token). Used for authentication with game backends, dedicated server token validation, and secure player identity verification in multiplayer.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": { "type": "string", "enum": ["create", "validate", "decode", "inspect"], "description": "JWT operation." },
        "token": { "type": "string", "description": "JWT string (for validate/decode/inspect).", "default": "" },
        "payload": { "type": "object", "description": "JWT payload claims (for create).", "additionalProperties": true, "default": {} },
        "secret": { "type": "string", "description": "Signing secret or key (for create/validate).", "default": "" },
        "algorithm": { "type": "string", "enum": ["HS256", "HS384", "HS512", "RS256", "RS384", "RS512"], "default": "HS256" },
        "expiration_seconds": { "type": "integer", "description": "Token expiration in seconds (for create).", "default": 3600 }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },

  {
    "_comment": "=== EDITOR DOCUMENTATION === (API: Editor/Documentation)  UE Editor documentation system. FDocumentationModule, IDocumentationProvider, UDocumentationCommandlet. Generates and serves documentation for editor UI elements, classes, and properties. Provides the '?' help button functionality in detail panels."
  },
  {
    "name": "editordocs.search_documentation",
    "description": "Search UE editor documentation for a class, property, or concept. Queries the built-in documentation system that powers the '?' help buttons in the editor. Returns documentation excerpts, URL links, and tooltip text.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "query": { "type": "string", "description": "Search term (class name, property name, or concept)." },
        "doc_type": { "type": "string", "enum": ["class", "property", "widget", "all"], "default": "all" },
        "max_results": { "type": "integer", "default": 10 }
      },
      "additionalProperties": false,
      "required": ["query"]
    }
  },
  {
    "name": "editordocs.get_class_docs",
    "description": "Get full documentation for a specific UClass  tooltip, metadata comments, category, property descriptions, and function signatures. Extracts documentation from the editor's reflection system.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "class_name": { "type": "string", "description": "UClass name (e.g. 'ACharacter', 'UStaticMeshComponent')." },
        "include_properties": { "type": "boolean", "description": "Include property documentation.", "default": true },
        "include_functions": { "type": "boolean", "description": "Include function signatures.", "default": false }
      },
      "additionalProperties": false,
      "required": ["class_name"]
    }
  },

  {
    "_comment": "=== PROPERTY EDITOR === (API: Editor/PropertyEditor)  Details panel customization and property inspection. FPropertyEditorModule, IDetailsView, IDetailCustomization, IPropertyTypeCustomization. Manages the Details panel that shows object properties. Enables custom property layouts, sections, and widget overrides."
  },
  {
    "name": "propertyeditor.inspect_details",
    "description": "Inspect the Details panel properties of a selected actor or asset. Returns all visible property categories, names, values, types, and metadata. Like reading the Details panel programmatically.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "target": { "type": "string", "description": "Actor label or asset path to inspect." },
        "category_filter": { "type": "string", "description": "Filter by property category name.", "default": "" },
        "include_hidden": { "type": "boolean", "description": "Include properties hidden from the Details panel.", "default": false },
        "include_metadata": { "type": "boolean", "description": "Include UPROPERTY metadata (EditCondition, ClampMin, etc.).", "default": false },
        "max_depth": { "type": "integer", "description": "How deep to traverse nested structs.", "default": 2 }
      },
      "additionalProperties": false,
      "required": ["target"]
    }
  },
  {
    "name": "propertyeditor.set_properties_batch",
    "description": "Set multiple properties on an actor or asset in a single batch operation. More efficient than setting one property at a time. Supports nested property paths (e.g. 'StaticMeshComponent.RelativeLocation.X').",
    "inputSchema": {
      "type": "object",
      "properties": {
        "target": { "type": "string", "description": "Actor label or asset path." },
        "properties": { "type": "object", "description": "Map of property_pathvalue to set. Supports dot notation for nested properties.", "additionalProperties": true },
        "transact": { "type": "boolean", "description": "Wrap in an undo transaction.", "default": true }
      },
      "additionalProperties": false,
      "required": ["target", "properties"]
    }
  },

  {
    "_comment": "=== SEQUENCER === (API: Editor/Sequencer, Editor/SequencerCore, Editor/SequencerWidgets)  Level Sequence (cinematic) editor. ISequencer interface for timeline editing. FSequencerModule manages sequencer instances. Track types: Actor, Camera, Audio, Event, Fade, Material Parameter, Transform, Skeletal Animation, etc. The primary tool for cinematics, in-game cutscenes, and scripted sequences."
  },
  {
    "name": "sequencer.create_sequence",
    "description": "Create a new Level Sequence asset for cinematics/cutscenes. Level Sequences contain tracks, keyframes, and bindings to actors for timeline-driven animation and events.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string", "description": "Path for the new LevelSequence (e.g. /Game/Cinematics/IntroSequence)." },
        "sequence_name": { "type": "string", "default": "" },
        "frame_rate": { "type": "integer", "description": "Playback frame rate.", "default": 30 },
        "playback_range_seconds": { "type": "number", "description": "Initial playback range length in seconds.", "default": 10.0 }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "sequencer.add_track",
    "description": "Add a track to a Level Sequence. Common tracks: Actor binding (possessable or spawnable), Camera Cut, Audio, Fade, Event, Level Visibility, Material Parameter Collection. Possessable tracks bind to existing level actors; Spawnable tracks spawn actors when the sequence plays.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "sequence_path": { "type": "string", "description": "LevelSequence asset path." },
        "track_type": { "type": "string", "enum": ["actor_possessable", "actor_spawnable", "camera_cut", "audio", "fade", "event", "level_visibility", "material_parameter", "folder"], "description": "Type of track to add." },
        "actor_label": { "type": "string", "description": "Actor label for actor binding tracks.", "default": "" },
        "actor_class": { "type": "string", "description": "Actor class to spawn (for spawnable tracks).", "default": "" },
        "track_name": { "type": "string", "description": "Display name for the track.", "default": "" }
      },
      "additionalProperties": false,
      "required": ["sequence_path", "track_type"]
    }
  },
  {
    "name": "sequencer.add_section",
    "description": "Add a section (sub-track) to an existing actor binding in a Level Sequence. Sections include: Transform, Skeletal Animation, Event, Component tracks (visibility, material parameters, etc.), and custom property tracks.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "sequence_path": { "type": "string", "description": "LevelSequence asset path." },
        "binding_name": { "type": "string", "description": "Actor binding name (actor label or track name)." },
        "section_type": { "type": "string", "enum": ["transform", "skeletal_animation", "event", "visibility", "material", "float_property", "bool_property", "color_property"], "description": "Type of section/sub-track." },
        "property_name": { "type": "string", "description": "Property name (for property tracks).", "default": "" },
        "animation_path": { "type": "string", "description": "AnimSequence asset (for skeletal_animation sections).", "default": "" }
      },
      "additionalProperties": false,
      "required": ["sequence_path", "binding_name", "section_type"]
    }
  },
  {
    "name": "sequencer.add_keyframe",
    "description": "Add a keyframe to a sequencer track section at a specific time. Supports transform, float, bool, color, and event keyframes. Keyframes define the timeline animation  the sequencer interpolates between them.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "sequence_path": { "type": "string", "description": "LevelSequence asset path." },
        "binding_name": { "type": "string", "description": "Actor binding name." },
        "section_type": { "type": "string", "enum": ["transform", "float", "bool", "color", "event"], "default": "transform" },
        "time_seconds": { "type": "number", "description": "Keyframe time in seconds." },
        "value": { "type": "object", "description": "Keyframe value. For transform: {location:{x,y,z}, rotation:{pitch,yaw,roll}, scale:{x,y,z}}. For float: {value: number}. For event: {event_name: string}.", "additionalProperties": true },
        "interpolation": { "type": "string", "enum": ["auto", "linear", "constant", "cubic"], "default": "auto" }
      },
      "additionalProperties": false,
      "required": ["sequence_path", "binding_name", "time_seconds", "value"]
    }
  },

  {
    "_comment": "=== SEQUENCE RECORDER === (API: Editor/SequenceRecorder, Editor/SequenceRecorderSections)  Records gameplay into Level Sequences. FSequenceRecorder captures actor transforms, skeletal animations, particle state, audio, and more. Sections define what gets recorded (FAnimSequenceRecorderSection, FTransformRecorderSection, etc.). Useful for capturing gameplay for cinematics or debugging."
  },
  {
    "name": "sequencerecorder.configure_recorder",
    "description": "Configure the Sequence Recorder settings: what to record (transforms, animations, audio, particles), recording groups, target sequence destination, and quality settings.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "output_path": { "type": "string", "description": "Output path for recorded sequences.", "default": "/Game/Recordings" },
        "record_transforms": { "type": "boolean", "default": true },
        "record_animations": { "type": "boolean", "default": true },
        "record_audio": { "type": "boolean", "default": false },
        "record_visibility": { "type": "boolean", "default": true },
        "animation_sample_rate": { "type": "integer", "description": "Animation recording sample rate (Hz).", "default": 30 },
        "record_nearby_radius": { "type": "number", "description": "Auto-record actors within this radius (0 to disable).", "default": 0 }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "sequencerecorder.add_recording_target",
    "description": "Add an actor as a recording target. The Sequence Recorder will capture this actor's transform, skeletal animation, and property changes during recording.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor_label": { "type": "string", "description": "Actor label to record." },
        "record_sections": { "type": "array", "items": { "type": "string", "enum": ["transform", "animation", "audio", "particles", "properties"] }, "description": "What to record for this actor.", "default": ["transform", "animation"] }
      },
      "additionalProperties": false,
      "required": ["actor_label"]
    }
  },

  {
    "_comment": "=== STRUCT VIEWER === (API: Editor/StructViewer)  Struct hierarchy browser. SStructViewer widget, FStructViewerNode. Similar to ClassViewer but for UScriptStruct types. Browse, search, and inspect struct hierarchies  useful for finding DataTable row types, GAS attribute types, and config structs."
  },
  {
    "name": "structviewer.find_structs",
    "description": "Search for UScriptStruct types matching a pattern. Similar to ClassViewer but for structs. Returns struct name, module, parent struct, and property list. Useful for finding DataTable row structs, input structs, animation data structs, etc.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "search_pattern": { "type": "string", "description": "Name pattern to search for (supports wildcards)." },
        "parent_struct": { "type": "string", "description": "Filter by parent struct (e.g. 'FTableRowBase' for DataTable rows).", "default": "" },
        "module_filter": { "type": "string", "description": "Filter by module name.", "default": "" },
        "include_properties": { "type": "boolean", "description": "Include property list in results.", "default": false },
        "max_results": { "type": "integer", "default": 25 }
      },
      "additionalProperties": false,
      "required": ["search_pattern"]
    }
  },
  {
    "name": "structviewer.inspect_struct",
    "description": "Get detailed information about a specific UScriptStruct: all properties with types, offsets, metadata, parent struct, size, and alignment. Essential for understanding DataTable row layouts and struct composition.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "struct_name": { "type": "string", "description": "Struct name (e.g. 'FVector', 'FGameplayTag', 'FMyDataTableRow')." },
        "include_inherited": { "type": "boolean", "description": "Include properties from parent structs.", "default": true }
      },
      "additionalProperties": false,
      "required": ["struct_name"]
    }
  },

  {
    "_comment": "=== WORLD BROWSER === (API: Editor/WorldBrowser)  World Composition and streaming level management. FWorldTileInfo, FWorldBrowserModule. Manages level streaming, World Partition tile visualization, World Composition layer setup, and sub-level organization. Used for large open worlds."
  },
  {
    "name": "worldbrowser.list_levels",
    "description": "List all streaming levels and sub-levels in the current world. Returns level names, streaming method, loaded state, visibility, transform offset, and layer association. Essential for managing World Composition or World Partition setups.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "filter": { "type": "string", "description": "Name pattern filter.", "default": "" },
        "include_unloaded": { "type": "boolean", "description": "Include levels not currently loaded.", "default": true }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "worldbrowser.manage_sublevel",
    "description": "Add, remove, load, or unload a streaming sub-level. Configure streaming distance, always-loaded flag, and level transform offset for World Composition.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": { "type": "string", "enum": ["add", "remove", "load", "unload", "set_visible", "set_current", "set_transform"], "description": "Sub-level management operation." },
        "level_path": { "type": "string", "description": "Sub-level asset path (e.g. /Game/Maps/SubLevels/Combat_Area)." },
        "always_loaded": { "type": "boolean", "description": "Mark as always loaded (no streaming).", "default": false },
        "streaming_distance": { "type": "number", "description": "Streaming distance threshold in cm.", "default": 0 },
        "transform_offset": { "type": "object", "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }, "description": "Level position offset." }
      },
      "additionalProperties": false,
      "required": ["operation", "level_path"]
    }
  },

  {
    "_comment": "=== RUNTIME CORE === (API: Runtime/Core)  Foundational UE runtime: console commands, config system, module management, logging, delegates, math, containers, async tasks, platform abstraction. FCoreDelegates, IConsoleManager, GConfig, FModuleManager, FPlatformProcess. The bedrock everything is built on."
  },
  {
    "name": "uecore.execute_console_command",
    "description": "Execute a UE console command (CVar or exec command). Access the thousands of built-in console variables and commands: rendering settings (r.), streaming (s.), physics (p.), network (net.), stat displays, and more.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "command": { "type": "string", "description": "Console command to execute (e.g. 'stat fps', 'r.VSync 1', 'showflag.PostProcessing 0')." },
        "capture_output": { "type": "boolean", "description": "Try to capture command output.", "default": true }
      },
      "additionalProperties": false,
      "required": ["command"]
    }
  },
  {
    "name": "uecore.manage_config",
    "description": "Read or write UE configuration values from .ini files (DefaultEngine.ini, DefaultGame.ini, DefaultEditor.ini, etc.). Access GConfig to get/set project settings, plugin configurations, and engine defaults.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": { "type": "string", "enum": ["get", "set", "list_sections", "list_keys"], "description": "Config operation." },
        "config_file": { "type": "string", "enum": ["Engine", "Game", "Editor", "Input", "Scalability", "GameplayTags", "Custom"], "description": "Which .ini group.", "default": "Engine" },
        "section": { "type": "string", "description": "Section name (e.g. '/Script/Engine.RendererSettings').", "default": "" },
        "key": { "type": "string", "description": "Config key name.", "default": "" },
        "value": { "type": "string", "description": "Value to set (for set operation).", "default": "" },
        "custom_file": { "type": "string", "description": "Custom .ini file path (for Custom config_file).", "default": "" }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },
  {
    "name": "uecore.list_modules",
    "description": "List loaded UE modules or query module status. Returns module names, load state, and file paths. Useful for verifying plugin modules are loaded and checking engine module availability.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "filter": { "type": "string", "description": "Module name filter pattern.", "default": "" },
        "loaded_only": { "type": "boolean", "description": "Only list currently loaded modules.", "default": true },
        "max_results": { "type": "integer", "default": 50 }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== CORE UOBJECT === (API: Runtime/CoreUObject)  UObject system fundamentals. UObject, UClass, UStruct, UFunction, UProperty/FProperty, UPackage overview. Reflection, CDO access, object iteration, property introspection, garbage collection roots, reference tracking. The UObject model is the foundation of all gameplay code."
  },
  {
    "name": "coreuobject.find_objects",
    "description": "Find UObjects in memory by class, name, or outer. Uses UObject iterators and TObjectRange to locate loaded objects. Returns object path, class, outer, and flags. Powerful for debugging object lifecycle and reference issues.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "class_name": { "type": "string", "description": "UClass to filter by (e.g. 'StaticMeshComponent', 'SkeletalMesh').", "default": "" },
        "name_pattern": { "type": "string", "description": "Object name pattern (supports wildcards).", "default": "" },
        "outer_path": { "type": "string", "description": "Filter by Outer object path.", "default": "" },
        "include_default_objects": { "type": "boolean", "description": "Include CDOs (Class Default Objects).", "default": false },
        "max_results": { "type": "integer", "default": 25 }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "coreuobject.inspect_class",
    "description": "Deep-inspect a UClass using CoreUObject reflection: all UProperties (with type, offset, flags, metadata), UFunctions (signatures, flags), implemented interfaces, class flags, parent chain, and CDO values. More detailed than classviewer  shows internal reflection data.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "class_name": { "type": "string", "description": "UClass name (e.g. 'ACharacter', 'UStaticMeshComponent')." },
        "include_functions": { "type": "boolean", "description": "Include UFunction list.", "default": false },
        "include_properties": { "type": "boolean", "description": "Include FProperty/UProperty details.", "default": true },
        "include_interfaces": { "type": "boolean", "description": "Include implemented interfaces.", "default": true },
        "include_cdo_values": { "type": "boolean", "description": "Include CDO default values for each property.", "default": false },
        "include_inherited": { "type": "boolean", "description": "Include inherited members.", "default": false }
      },
      "additionalProperties": false,
      "required": ["class_name"]
    }
  },
  {
    "name": "coreuobject.get_references",
    "description": "Track UObject references  find what references a given object (inbound refs) or what objects it references (outbound refs). Uses FReferenceFinder / FArchiveCountMem. Essential for debugging memory leaks, finding why objects aren't garbage collected, and understanding object graphs.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "object_path": { "type": "string", "description": "Object path to analyze." },
        "direction": { "type": "string", "enum": ["inbound", "outbound", "both"], "description": "Reference direction to trace.", "default": "inbound" },
        "include_weak": { "type": "boolean", "description": "Include weak references.", "default": false },
        "max_depth": { "type": "integer", "description": "Max traversal depth for reference chains.", "default": 1 },
        "max_results": { "type": "integer", "default": 25 }
      },
      "additionalProperties": false,
      "required": ["object_path"]
    }
  },

  {
    "_comment": "=== GAMEPLAY TAGS (RUNTIME) === (API: Runtime/GameplayTags)  Runtime GameplayTag system. FGameplayTag (single hierarchical tag), FGameplayTagContainer (tag set on actors/components), FGameplayTagQuery (complex matching expressions), UGameplayTagsManager (singleton registry). Enables data-driven tag-based logic for abilities, AI, items, states, and more. Complements gameplaytagseditor.* (editor CRUD) with runtime query/matching/container operations on live objects."
  },
  {
    "name": "gameplaytags.query_actor_tags",
    "description": "Query the GameplayTagContainer on an actor or component via IGameplayTagAssetInterface. Returns all tags, or checks for specific tag matches (HasTag, HasAny, HasAll, HasExact). Works on any actor implementing IGameplayTagAssetInterface (AbilitySystemComponent, SmartObject, AI controllers, etc.).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor_label": { "type": "string", "description": "Actor label or path to query." },
        "component_name": { "type": "string", "description": "Specific component name (e.g. 'AbilitySystemComponent'). If empty, queries the actor.", "default": "" },
        "match_type": { "type": "string", "enum": ["list_all", "has_tag", "has_any", "has_all", "has_exact"], "description": "Match operation.", "default": "list_all" },
        "tags": { "type": "array", "items": { "type": "string" }, "description": "Tags to match against (for has_tag/has_any/has_all/has_exact).", "default": [] }
      },
      "additionalProperties": false,
      "required": ["actor_label"]
    }
  },
  {
    "name": "gameplaytags.modify_container",
    "description": "Add or remove GameplayTags from a FGameplayTagContainer on an actor/component at runtime. Used to grant/revoke state tags (e.g. 'State.Stunned', 'Buff.Shield'), trigger GAS tag-based responses, or update AI behavior tags.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor_label": { "type": "string", "description": "Actor label or path." },
        "component_name": { "type": "string", "description": "Component with the tag container.", "default": "" },
        "operation": { "type": "string", "enum": ["add", "remove", "reset", "append_container"], "description": "Container modification." },
        "tags": { "type": "array", "items": { "type": "string" }, "description": "Tags to add/remove." },
        "exact_match": { "type": "boolean", "description": "For remove: require exact tag match (not parent tags).", "default": true }
      },
      "additionalProperties": false,
      "required": ["actor_label", "operation", "tags"]
    }
  },
  {
    "name": "gameplaytags.evaluate_query",
    "description": "Build and evaluate a FGameplayTagQuery expression against a tag container. Tag queries support complex boolean logic: AllTagsMatch, AnyTagsMatch, NoTagsMatch, and nested AND/OR/NOT groups. Returns whether the query passes and the matching details.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor_label": { "type": "string", "description": "Actor to evaluate the query against." },
        "component_name": { "type": "string", "default": "" },
        "query_expression": { "type": "object", "description": "Query expression tree. Use {type:'all|any|none', tags:[...]} for simple queries or {type:'and|or|not', sub:[...]} for compound logic.", "properties": {
          "type": { "type": "string", "enum": ["all", "any", "none", "and", "or", "not"], "description": "Query node type." },
          "tags": { "type": "array", "items": { "type": "string" }, "description": "Tags for leaf nodes (all/any/none)." },
          "sub": { "type": "array", "description": "Sub-expressions for compound nodes (and/or/not).", "items": { "type": "object" } }
        }, "additionalProperties": false }
      },
      "additionalProperties": false,
      "required": ["actor_label", "query_expression"]
    }
  },
  {
    "name": "gameplaytags.get_tag_info",
    "description": "Get metadata about registered GameplayTags from UGameplayTagsManager: tag hierarchy (parent/children), source .ini file, dev comment, whether it's a restricted tag, and all registered tags matching a filter. Runtime complement to gameplaytagseditor.search_tags.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "tag_name": { "type": "string", "description": "Tag to query (e.g. 'Character.State'). Use '*' or partial for pattern matching.", "default": "" },
        "include_children": { "type": "boolean", "description": "Include child tags in hierarchy.", "default": true },
        "include_source": { "type": "boolean", "description": "Include source file info.", "default": true },
        "max_results": { "type": "integer", "default": 50 }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== GAMEPLAY TASKS (RUNTIME) === (API: Runtime/GameplayTasks)  Lightweight async task framework. UGameplayTask is the base for latent, tickable tasks driven by UGameplayTasksComponent. Tasks have priority, pausing, external cancel/end, resource overlap policies. Used extensively by GAS (UAbilityTask), AI (UBTTask_GameplayTaskBase), and custom game systems. Key classes: UGameplayTask, UGameplayTasksComponent, UGameplayTaskOwnerInterface, UGameplayTask_ClaimResource, UGameplayTask_SpawnActor, UGameplayTask_WaitDelay, UGameplayTask_TimeLimitedExecution."
  },
  {
    "name": "gameplaytasks.list_active_tasks",
    "description": "List active GameplayTasks running on an actor's UGameplayTasksComponent. Returns task class, priority, state (Active/Paused/Finished), resource claims, owning ability (if GAS), and tick status. Useful for debugging overlapping abilities, AI tasks, and resource contention.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor_label": { "type": "string", "description": "Actor label or path." },
        "include_finished": { "type": "boolean", "description": "Include recently finished tasks.", "default": false },
        "filter_class": { "type": "string", "description": "Filter by task class name (e.g. 'AbilityTask_WaitTargetData').", "default": "" }
      },
      "additionalProperties": false,
      "required": ["actor_label"]
    }
  },
  {
    "name": "gameplaytasks.inspect_task_component",
    "description": "Inspect the UGameplayTasksComponent on an actor: registered resource sets, task count by priority, active resource claims, task overlap policy, and event delegates. The component is the task scheduler  understanding its state is key to debugging ability/task conflicts.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor_label": { "type": "string", "description": "Actor label or path." },
        "include_resource_map": { "type": "boolean", "description": "Show current resource claim map.", "default": true },
        "include_priority_queue": { "type": "boolean", "description": "Show tasks sorted by priority.", "default": true }
      },
      "additionalProperties": false,
      "required": ["actor_label"]
    }
  },
  {
    "name": "gameplaytasks.manage_task",
    "description": "Activate, pause, resume, or cancel a GameplayTask by name/index on an actor. Can also externally end a task with a result. Used for debugging task lifecycle or scripting task control from the agent.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "actor_label": { "type": "string", "description": "Actor label or path." },
        "operation": { "type": "string", "enum": ["activate", "pause", "resume", "cancel", "end"], "description": "Task operation." },
        "task_index": { "type": "integer", "description": "Task index from list_active_tasks.", "default": -1 },
        "task_class_filter": { "type": "string", "description": "Target task by class name instead of index.", "default": "" }
      },
      "additionalProperties": false,
      "required": ["actor_label", "operation"]
    }
  },

  {
    "_comment": "=== HTTP NETWORK REPLAY STREAMING === (API: Runtime/HttpNetworkReplayStreaming)  HTTP-based replay streaming backend. FHttpNetworkReplayStreamer implements INetworkReplayStreamer to record and play back game sessions via an HTTP replay server. Supports live spectation, killcam, match replays. Key classes: FHttpNetworkReplayStreamer, FHttpReplayHeaderParser, FHttpStreamFArchive. Works with UDemoNetDriver for network replay capture."
  },
  {
    "name": "replaystreaming.configure_http_streamer",
    "description": "Configure the HTTP Network Replay Streamer: server URL, auth credentials, upload chunk size, compression, and viewer settings. The HTTP streamer sends replay data to a remote server for storage, enabling web-based replay viewing and live spectation.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "server_url": { "type": "string", "description": "HTTP replay server URL (e.g. 'http://replay-server:8080/replays')." },
        "auth_token": { "type": "string", "description": "Authentication token for the replay server.", "default": "" },
        "chunk_upload_size_kb": { "type": "integer", "description": "Replay chunk size in KB before uploading.", "default": 512 },
        "enable_compression": { "type": "boolean", "description": "Compress replay data before upload.", "default": true },
        "max_concurrent_uploads": { "type": "integer", "description": "Max simultaneous chunk uploads.", "default": 2 },
        "enable_live_streaming": { "type": "boolean", "description": "Allow live spectation of in-progress replays.", "default": false }
      },
      "additionalProperties": false,
      "required": ["server_url"]
    }
  },
  {
    "name": "replaystreaming.manage_recording",
    "description": "Start, stop, or query replay recording via DemoNetDriver + HTTP streamer. Records network traffic for match replays and killcams. Can record specific actors, time windows, or full sessions.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": { "type": "string", "enum": ["start", "stop", "pause", "resume", "status", "add_event"], "description": "Recording operation." },
        "recording_name": { "type": "string", "description": "Friendly name for this recording.", "default": "" },
        "metadata": { "type": "object", "description": "Custom metadata tags (map name, game mode, players).", "additionalProperties": { "type": "string" }, "default": {} },
        "event_name": { "type": "string", "description": "Event name (for add_event  marks a point in the replay like 'KillEvent', 'ObjectiveCapture').", "default": "" },
        "event_time_offset": { "type": "number", "description": "Seconds offset for event timestamp.", "default": 0 }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },
  {
    "name": "replaystreaming.manage_playback",
    "description": "List available replays, start playback, seek to time/event, control playback speed. Replays can be played back locally via DemoNetDriver or streamed from the HTTP server for spectation.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": { "type": "string", "enum": ["list_replays", "play", "stop", "seek", "set_speed", "goto_event", "get_info"], "description": "Playback operation." },
        "replay_id": { "type": "string", "description": "Replay ID or name (from list_replays).", "default": "" },
        "seek_time_seconds": { "type": "number", "description": "Seek to time in seconds (for seek).", "default": 0 },
        "playback_speed": { "type": "number", "description": "Playback speed multiplier (for set_speed).", "default": 1.0 },
        "event_name": { "type": "string", "description": "Event name to jump to (for goto_event).", "default": "" },
        "filter_metadata": { "type": "object", "description": "Filter replays by metadata tags (for list_replays).", "additionalProperties": { "type": "string" }, "default": {} }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },

  {
    "_comment": "=== JSON OBJECT GRAPH === (API: Runtime/JsonObjectGraph)  Serialization of UObject graphs to/from JSON with full reference preservation. FJsonObjectGraph, FJsonObjectGraphNode. Unlike basic JSON serialization, this handles circular references, UObject cross-references, subobjects, and instanced objects. Used for save systems, clipboard copy/paste of actor hierarchies, and level data interchange."
  },
  {
    "name": "jsonobjectgraph.export_object_graph",
    "description": "Export a UObject and its referenced subobject graph to JSON. Preserves cross-references between objects, handles circular deps, and serializes instanced subobjects. More powerful than basic JSON export  captures the full object network.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root_object_path": { "type": "string", "description": "Root UObject path to export (actor, component, asset)." },
        "output_file": { "type": "string", "description": "Output JSON file path. If empty, returns JSON string.", "default": "" },
        "include_subobjects": { "type": "boolean", "description": "Include owned subobjects (components, instanced objects).", "default": true },
        "include_references": { "type": "boolean", "description": "Follow and serialize referenced objects.", "default": false },
        "max_depth": { "type": "integer", "description": "Max reference traversal depth.", "default": 3 },
        "pretty_print": { "type": "boolean", "default": true },
        "skip_defaults": { "type": "boolean", "description": "Skip properties matching CDO values.", "default": true }
      },
      "additionalProperties": false,
      "required": ["root_object_path"]
    }
  },
  {
    "name": "jsonobjectgraph.import_object_graph",
    "description": "Import a UObject graph from JSON. Reconstructs objects with correct cross-references, reparents subobjects, and resolves dependencies. Can create new objects or update existing ones. Used for paste operations, save loading, and data migration.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "json_file": { "type": "string", "description": "JSON file path to import.", "default": "" },
        "json_string": { "type": "string", "description": "Inline JSON string (alternative to json_file).", "default": "" },
        "target_outer": { "type": "string", "description": "Outer object for created objects (e.g. a level path or package).", "default": "" },
        "overwrite_existing": { "type": "boolean", "description": "Overwrite objects that already exist at the target paths.", "default": false },
        "remap_references": { "type": "boolean", "description": "Remap cross-object references to new locations.", "default": true }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "jsonobjectgraph.diff_graphs",
    "description": "Compare two JSON object graph exports and produce a diff. Shows added, removed, and modified objects/properties. Useful for comparing save states, level snapshots, or tracking object changes over time.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "graph_a": { "type": "string", "description": "First JSON file path or inline JSON." },
        "graph_b": { "type": "string", "description": "Second JSON file path or inline JSON." },
        "ignore_properties": { "type": "array", "items": { "type": "string" }, "description": "Property names to exclude from diff.", "default": [] },
        "output_file": { "type": "string", "description": "Write diff report to file.", "default": "" }
      },
      "additionalProperties": false,
      "required": ["graph_a", "graph_b"]
    }
  },

  {
    "_comment": "=== JSON (RUNTIME CORE) === (API: Runtime/Json)  Low-level JSON DOM and streaming API. FJsonObject (JSON object node), FJsonValue (typed value: String/Number/Boolean/Array/Object/Null), FJsonSerializer (parse/stringify), TJsonReader/TJsonWriter (streaming reader/writer), FJsonDomBuilder (fluent DOM construction). This is the foundation that jsonblueprint, jsonserialization, and jsonobjectgraph build upon. Use for raw JSON file I/O, API response parsing, and custom serialization."
  },
  {
    "name": "jsoncore.parse_file",
    "description": "Parse a JSON file from disk into memory using FJsonSerializer::Deserialize + TJsonReader. Returns the parsed JSON structure (objects, arrays, values) as a navigable tree. Lower-level than jsonserialization  works with raw JSON rather than UStructs.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "file_path": { "type": "string", "description": "Absolute or project-relative path to the JSON file." },
        "output_format": { "type": "string", "enum": ["tree", "flat", "summary"], "description": "How to present the parsed result: tree (hierarchical), flat (dot-notation keys), summary (types and counts only).", "default": "summary" },
        "max_depth": { "type": "integer", "description": "Max depth to display.", "default": 5 },
        "max_array_elements": { "type": "integer", "description": "Max array elements to show per array.", "default": 10 }
      },
      "additionalProperties": false,
      "required": ["file_path"]
    }
  },
  {
    "name": "jsoncore.write_file",
    "description": "Write JSON data to a file using FJsonSerializer::Serialize + TJsonWriter. Constructs a FJsonObject from the provided structure and writes it with configurable formatting (pretty/condensed, indent style).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "file_path": { "type": "string", "description": "Output file path." },
        "data": { "type": "object", "description": "JSON data to write.", "additionalProperties": true },
        "pretty_print": { "type": "boolean", "default": true },
        "indent_char": { "type": "string", "enum": ["tab", "2spaces", "4spaces"], "default": "tab" },
        "overwrite": { "type": "boolean", "description": "Overwrite if file exists.", "default": false }
      },
      "additionalProperties": false,
      "required": ["file_path", "data"]
    }
  },
  {
    "name": "jsoncore.query_json",
    "description": "Query values from a parsed JSON file using dot-notation or JSONPath-like expressions. Navigate nested objects and arrays without loading the full tree. E.g. 'Config.Rendering.Shadows[0].Quality'.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "file_path": { "type": "string", "description": "JSON file to query." },
        "json_string": { "type": "string", "description": "Inline JSON string (alternative to file_path).", "default": "" },
        "query_path": { "type": "string", "description": "Dot-notation path (e.g. 'Players[0].Name', 'Settings.Audio.Volume')." },
        "return_type": { "type": "string", "enum": ["value", "type", "exists", "children"], "description": "What to return: the value, its JSON type, whether it exists, or child keys.", "default": "value" }
      },
      "additionalProperties": false,
      "required": ["query_path"]
    }
  },
  {
    "name": "jsoncore.modify_json",
    "description": "Modify values in a JSON file in-place: set, delete, or append fields/array elements using dot-notation paths. Reads the file, applies modifications via FJsonObject/FJsonValue manipulation, and writes back.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "file_path": { "type": "string", "description": "JSON file to modify." },
        "operations": { "type": "array", "items": { "type": "object", "properties": {
          "op": { "type": "string", "enum": ["set", "delete", "append", "insert"], "description": "Modification type." },
          "path": { "type": "string", "description": "Dot-notation path to target." },
          "value": { "description": "New value (for set/append/insert). Any JSON type." }
        }, "required": ["op", "path"] }, "description": "List of modifications to apply in order." },
        "create_backup": { "type": "boolean", "description": "Create a .bak backup before modifying.", "default": true }
      },
      "additionalProperties": false,
      "required": ["file_path", "operations"]
    }
  },

  {
    "_comment": "=== NAVIGATION SYSTEM === (API: Runtime/NavigationSystem, Runtime/Navmesh)  Full navigation system: UNavigationSystemV1 (singleton manager), ANavigationData (abstract nav data), ARecastNavMesh (navmesh implementation), UNavArea (area cost classes), FNavAgentProperties (agent size/caps), UPathFollowingComponent, FNavigationPath, NavMesh generation/query/debugging. The central runtime for AI pathfinding and movement."
  },
  {
    "name": "navsystem.build_navmesh",
    "description": "Trigger NavMesh build/rebuild for the current level. Can rebuild the full navmesh or only dirty areas. Configure generation settings: cell size/height, agent dimensions, tile size, and simplification. Uses UNavigationSystemV1::Build.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "rebuild_mode": { "type": "string", "enum": ["full", "dirty_only", "dirty_areas"], "default": "dirty_only" },
        "nav_data_filter": { "type": "string", "description": "NavData asset name filter (for multiple navmeshes).", "default": "" },
        "cell_size": { "type": "number", "description": "Recast cell size override (cm). Smaller = more detail but slower.", "default": 0 },
        "cell_height": { "type": "number", "description": "Recast cell height override (cm).", "default": 0 },
        "agent_radius": { "type": "number", "description": "Agent radius override (cm).", "default": 0 },
        "agent_height": { "type": "number", "description": "Agent height override (cm).", "default": 0 },
        "tile_size": { "type": "integer", "description": "Tile size in cells (0 = default).", "default": 0 }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "navsystem.query_path",
    "description": "Query a navigation path between two points. Returns the full path points, distance, area types traversed, partial path flag, and path cost. Uses UNavigationSystemV1::FindPathSync or FindPathAsync.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "start": { "type": "object", "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }, "description": "Start position." },
        "end": { "type": "object", "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }, "description": "Goal position." },
        "agent_class": { "type": "string", "description": "Agent class for nav preferences (affects area costs, agent size).", "default": "" },
        "include_path_points": { "type": "boolean", "description": "Return the full path point list.", "default": true },
        "allow_partial": { "type": "boolean", "description": "Accept partial paths to nearest reachable point.", "default": true },
        "query_filter": { "type": "string", "description": "Navigation query filter class name.", "default": "" }
      },
      "additionalProperties": false,
      "required": ["start", "end"]
    }
  },
  {
    "name": "navsystem.test_reachability",
    "description": "Test whether a point is reachable on the navmesh, or whether two points can reach each other. Faster than a full path query  just returns bool + nearest nav point. Uses NavigationSystem point-on-navmesh and reachability tests.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "test_type": { "type": "string", "enum": ["point_on_navmesh", "reachable_between", "project_to_navmesh"], "description": "Test type." },
        "point_a": { "type": "object", "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } } },
        "point_b": { "type": "object", "properties": { "x": { "type": "number" }, "y": { "type": "number" }, "z": { "type": "number" } }, "description": "Second point (for reachable_between)." },
        "query_extent": { "type": "number", "description": "Search radius for projection to navmesh (cm).", "default": 200 },
        "agent_class": { "type": "string", "default": "" }
      },
      "additionalProperties": false,
      "required": ["test_type", "point_a"]
    }
  },
  {
    "name": "navsystem.configure_nav_areas",
    "description": "List, create, or configure NavArea classes. NavAreas define traversal cost multipliers and flags for different surface types (road, grass, water, obstacle). Areas are painted onto the navmesh via NavModifierVolumes or mesh area assignments.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": { "type": "string", "enum": ["list", "get_info", "set_cost", "create"], "description": "NavArea operation." },
        "area_class": { "type": "string", "description": "NavArea class name (e.g. 'NavArea_Obstacle', 'NavArea_LowHeight').", "default": "" },
        "cost_multiplier": { "type": "number", "description": "Traversal cost multiplier (for set_cost). Higher = AI avoids.", "default": 1.0 },
        "entering_cost": { "type": "number", "description": "One-time cost to enter this area.", "default": 0 },
        "area_flags": { "type": "integer", "description": "Custom area flag bits.", "default": 0 }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },
  {
    "name": "navsystem.inspect_navmesh",
    "description": "Inspect the current navmesh state: tile count, poly count, memory usage, generation time, supported agents, nav bounds, and per-tile debug info. Uses ARecastNavMesh properties and UNavigationSystemV1 queries.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "include_stats": { "type": "boolean", "description": "Include memory/performance stats.", "default": true },
        "include_bounds": { "type": "boolean", "description": "Include nav bounds volumes info.", "default": true },
        "include_agents": { "type": "boolean", "description": "List supported nav agent configs.", "default": true },
        "tile_filter": { "type": "string", "description": "Filter tiles by area (bounding box as 'x1,y1,z1,x2,y2,z2').", "default": "" }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  {
    "_comment": "=== NETWORK FILE SYSTEM === (API: Runtime/NetworkFileSystem)  File serving over the network for cook-on-the-fly and remote deployment. FNetworkFileServer, FNetworkFileServerHttp. Serves cooked content to remote target devices (mobile, console) during iterative development. Handles file request/response, directory watching, and sandbox file operations."
  },
  {
    "name": "networkfilesystem.manage_server",
    "description": "Start, stop, or query the Network File Server used for cook-on-the-fly deployment. The NFS serves cooked content to remote devices over the network, enabling rapid iteration without full deployment.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": { "type": "string", "enum": ["start", "stop", "status", "list_connections"], "description": "Server operation." },
        "port": { "type": "integer", "description": "Server port.", "default": 41898 },
        "target_platform": { "type": "string", "description": "Target platform filter (e.g. 'Android', 'IOS').", "default": "" }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },

  {
    "_comment": "=== ULANG (VERSE) === (API: Runtime/uLangCore, Runtime/uLangJSON, Runtime/uLangUE)  Verse language runtime integration. uLangCore provides the core Verse type system, expression evaluation, and semantic model. uLangJSON enables VerseJSON serialization. uLangUE bridges Verse types to UE types (UObject, UStruct, delegates). Used by Verse scripting in UEFN and Fortnite Creative."
  },
  {
    "name": "ulang.inspect_verse_types",
    "description": "Inspect Verse (uLang) type definitions available in the project: classes, interfaces, enums, and their members. Queries the uLang semantic model for type information, inheritance, and function signatures.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "type_filter": { "type": "string", "description": "Type name pattern to search for.", "default": "" },
        "module_filter": { "type": "string", "description": "Verse module/package filter.", "default": "" },
        "include_members": { "type": "boolean", "description": "Include class/interface members.", "default": true },
        "max_results": { "type": "integer", "default": 25 }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "ulang.evaluate_expression",
    "description": "Evaluate a Verse (uLang) expression in the current context. Can query values, test type compatibility, and inspect Verse data. Uses the uLang expression evaluator.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "expression": { "type": "string", "description": "Verse expression to evaluate." },
        "context_path": { "type": "string", "description": "Evaluation context (module or object path).", "default": "" }
      },
      "additionalProperties": false,
      "required": ["expression"]
    }
  },
  {
    "name": "ulang.verse_json_convert",
    "description": "Convert between Verse data structures and JSON using uLangJSON. Serialize Verse objects to JSON for export/debugging, or deserialize JSON into Verse-compatible types.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": { "type": "string", "enum": ["to_json", "from_json", "validate_schema"], "description": "Conversion operation." },
        "verse_path": { "type": "string", "description": "Verse object/type path (for to_json).", "default": "" },
        "json_data": { "type": "string", "description": "JSON string (for from_json).", "default": "" },
        "target_type": { "type": "string", "description": "Target Verse type (for from_json/validate_schema).", "default": "" },
        "pretty_print": { "type": "boolean", "default": true }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },

  {
    "_comment": "=== UE LIBRARY === (API: Runtime/UELibrary)  Common utility library classes and functions. Helper functions, math utilities, string formatting, platform abstraction helpers. Provides shared utilities used across engine modules."
  },
  {
    "name": "uelibrary.call_utility",
    "description": "Call a UE utility library function: string manipulation (FString helpers), math operations (FMath), platform queries (FPlatformMisc), name formatting, GUID generation, path utilities, and other common helpers from the UELibrary module.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "category": { "type": "string", "enum": ["string", "math", "platform", "path", "guid", "name", "misc"], "description": "Utility category." },
        "function_name": { "type": "string", "description": "Function name to call (e.g. 'GenerateGuid', 'SanitizeFloat', 'GetPlatformName')." },
        "arguments": { "type": "object", "description": "Function arguments as key-value pairs.", "additionalProperties": true, "default": {} }
      },
      "additionalProperties": false,
      "required": ["category", "function_name"]
    }
  },

  {
    "_comment": "=== UNIVERSAL OBJECT LOCATOR === (API: Runtime/UniversalObjectLocator)  Persistent, serializable object references that survive level streaming, PIE, packaging, and world partition. FUniversalObjectLocator replaces soft/hard object paths with a more robust locator system. Supports custom fragment types for resolving objects in different contexts (level instances, data layers, streaming). Key for referencing actors across world partition cells."
  },
  {
    "name": "objectlocator.resolve_locator",
    "description": "Resolve a UniversalObjectLocator string to the actual UObject it references. Locators persist across level streaming, PIE, packaging, and world partition boundaries  more robust than soft object paths.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "locator_string": { "type": "string", "description": "UniversalObjectLocator string to resolve." },
        "context_object": { "type": "string", "description": "Context object for relative resolution.", "default": "" },
        "return_details": { "type": "boolean", "description": "Return resolved object details (class, path, outer, validity).", "default": true }
      },
      "additionalProperties": false,
      "required": ["locator_string"]
    }
  },
  {
    "name": "objectlocator.create_locator",
    "description": "Create a UniversalObjectLocator for an actor or object. The locator string can be stored, serialized, and later resolved even after level streaming, world partition changes, or PIE transitions.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "object_path": { "type": "string", "description": "Actor label or object path to create a locator for." },
        "locator_type": { "type": "string", "enum": ["auto", "actor", "component", "asset", "level_instance"], "description": "Locator fragment type hint.", "default": "auto" },
        "context_object": { "type": "string", "description": "Context for relative locators.", "default": "" }
      },
      "additionalProperties": false,
      "required": ["object_path"]
    }
  },

  {
    "_comment": "=== WEB BROWSER === (API: Runtime/WebBrowser, Runtime/WebBrowserTexture)  Embedded Chromium (CEF) web browser for UE. UWebBrowserWidget (Slate/UMG widget), IWebBrowserWindow (browser instance), FWebBrowserTexture (renders browser to a texture for 3D in-world display). Supports JavaScriptUE interop, cookie management, custom schemes, and transparent backgrounds. Used for in-game web views, storefronts, login screens, and HTML-based HUD."
  },
  {
    "name": "webbrowser.open_browser",
    "description": "Open an embedded web browser widget or create a browser texture for in-world display. The browser uses Chromium (CEF) and supports full HTML5/CSS3/JS. Can render to a UMG widget or to a texture for 3D surfaces.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "url": { "type": "string", "description": "Initial URL to load." },
        "mode": { "type": "string", "enum": ["widget", "texture", "offscreen"], "description": "Browser mode: widget (UMG overlay), texture (render to texture for 3D), offscreen (no display, scripting only).", "default": "widget" },
        "width": { "type": "integer", "description": "Browser viewport width in pixels.", "default": 1280 },
        "height": { "type": "integer", "description": "Browser viewport height in pixels.", "default": 720 },
        "transparent": { "type": "boolean", "description": "Enable transparent background (for overlay use).", "default": false },
        "browser_name": { "type": "string", "description": "Unique name for this browser instance.", "default": "" }
      },
      "additionalProperties": false,
      "required": ["url"]
    }
  },
  {
    "name": "webbrowser.execute_js",
    "description": "Execute JavaScript in an embedded browser instance. Enables UEJS interop: call JS functions from UE, query DOM values, manipulate page content. Combined with BindUObject, enables bidirectional communication between game code and web content.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "browser_name": { "type": "string", "description": "Browser instance name.", "default": "" },
        "script": { "type": "string", "description": "JavaScript code to execute." },
        "capture_result": { "type": "boolean", "description": "Try to capture the JS return value.", "default": true }
      },
      "additionalProperties": false,
      "required": ["script"]
    }
  },
  {
    "name": "webbrowser.manage_browser",
    "description": "Navigate, reload, close, or query browser state. Control the embedded browser lifecycle: go back/forward, stop loading, get current URL/title, manage cookies, and close the browser.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "browser_name": { "type": "string", "description": "Browser instance name.", "default": "" },
        "operation": { "type": "string", "enum": ["navigate", "reload", "stop", "back", "forward", "close", "get_url", "get_title", "clear_cookies", "list_browsers"], "description": "Browser operation." },
        "url": { "type": "string", "description": "URL for navigate operation.", "default": "" }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },

  {
    "_comment": "=== MATH CORE === (API: Runtime/MathCore)  Extended math library beyond FMath. TBigInt, FIntPoint, FIntRect, FIntVector, FFloat16, FFloat16Color, FFloatInterval, FInt32Interval, TSHVector (spherical harmonics), FConvexVolume, FMatrix2x2, FQualifiedFrameTime, FFrameRate, FTimecode. Specialized numeric types, intervals, high-precision math, SH evaluation, convex hull tests, and frame/timecode utilities."
  },
  {
    "name": "mathcore.evaluate_expression",
    "description": "Evaluate a math expression using UE math types: vector/rotator/matrix arithmetic, SH (spherical harmonics) evaluation, interval operations, convex volume tests, frame rate conversions, and timecode calculations. Supports FVector, FRotator, FQuat, FMatrix, FIntVector, FFloat16, and more.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "expression": { "type": "string", "description": "Math expression (e.g. 'FVector(100,0,0).RotateAngleAxis(45, FVector::UpVector)', 'FFrameRate(30,1).AsDecimal()')." },
        "output_format": { "type": "string", "enum": ["value", "components", "string"], "default": "string" }
      },
      "additionalProperties": false,
      "required": ["expression"]
    }
  },
  {
    "name": "mathcore.convert_types",
    "description": "Convert between UE math/numeric types: FVectorFIntVector, FRotatorFQuatFMatrix, floatFFloat16, secondsFTimecodeFFrameNumber, FFrameRate conversions, FIntPointFVector2D, and more.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source_type": { "type": "string", "description": "Source type name (e.g. 'FRotator', 'FTimecode', 'float')." },
        "target_type": { "type": "string", "description": "Target type name." },
        "value": { "type": "object", "description": "Source value. For vectors: {x,y,z}. For rotators: {pitch,yaw,roll}. For timecode: {hours,minutes,seconds,frames}. For scalars: {value: number}.", "additionalProperties": true }
      },
      "additionalProperties": false,
      "required": ["source_type", "target_type", "value"]
    }
  },
  {
    "name": "mathcore.timecode_operations",
    "description": "Work with FTimecode and FFrameRate: convert between timecodes, frame numbers, and seconds. Calculate timecode arithmetic, validate drop-frame timecodes, and convert between frame rates. Essential for cinematic/sequencer work.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": { "type": "string", "enum": ["to_timecode", "from_timecode", "convert_frame_rate", "add_timecodes", "subtract_timecodes", "frames_to_seconds", "seconds_to_frames"], "description": "Timecode operation." },
        "timecode": { "type": "object", "properties": { "hours": { "type": "integer" }, "minutes": { "type": "integer" }, "seconds": { "type": "integer" }, "frames": { "type": "integer" } }, "description": "Timecode value (for from_timecode, add, subtract)." },
        "frame_number": { "type": "integer", "description": "Frame number (for to_timecode, frames_to_seconds).", "default": 0 },
        "seconds": { "type": "number", "description": "Time in seconds.", "default": 0 },
        "frame_rate": { "type": "number", "description": "Frame rate (e.g. 24, 30, 60).", "default": 30 },
        "target_frame_rate": { "type": "number", "description": "Target frame rate (for convert_frame_rate).", "default": 30 },
        "drop_frame": { "type": "boolean", "description": "Use drop-frame timecode.", "default": false }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },

  {
    "_comment": "=== INPUT CORE === (API: Runtime/InputCore)  Low-level input key/axis definitions and device detection. FKey (key identifier), EKeys (all platform keys enum), FKeyDetails (analog/digital/axis metadata), FInputDeviceId, FPlatformUserId, FInputDeviceScope. Foundation for EnhancedInput and legacy input  defines every key, gamepad button, touch, motion, and XR input. Also handles input device hot-plug detection and platform user mapping."
  },
  {
    "name": "inputcore.list_keys",
    "description": "List all registered FKey entries (keyboard keys, mouse buttons, gamepad axes, touch inputs, motion sensors, XR inputs). Filter by category, device type, or name pattern. Returns key name, display name, whether it's analog/digital/axis, and paired axis info.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "filter": { "type": "string", "description": "Key name pattern filter (e.g. 'Gamepad*', 'Mouse*', '*Trigger*').", "default": "" },
        "category": { "type": "string", "enum": ["all", "keyboard", "mouse", "gamepad", "touch", "motion", "xr", "analog"], "description": "Filter by input category.", "default": "all" },
        "analog_only": { "type": "boolean", "description": "Only return analog (axis) keys.", "default": false },
        "max_results": { "type": "integer", "default": 50 }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "inputcore.get_key_state",
    "description": "Query the current state of an input key: pressed/released, axis value, duration held. Works with any FKey including gamepad axes, mouse position, and touch inputs. Uses the player controller's input component state.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "key_name": { "type": "string", "description": "FKey name (e.g. 'SpaceBar', 'Gamepad_LeftTriggerAxis', 'LeftMouseButton')." },
        "player_index": { "type": "integer", "description": "Local player index.", "default": 0 }
      },
      "additionalProperties": false,
      "required": ["key_name"]
    }
  },
  {
    "name": "inputcore.list_input_devices",
    "description": "List connected input devices: gamepads, keyboards, mice, touch screens, XR controllers. Returns device ID, platform user mapping, device type, and connection status. Uses FInputDeviceId and platform input subsystem queries.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "device_type_filter": { "type": "string", "enum": ["all", "gamepad", "keyboard", "mouse", "touch", "xr"], "default": "all" },
        "connected_only": { "type": "boolean", "default": true }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  { "_comment": "=== BUILDSETTINGS  Runtime/BuildSettings: Build configuration queries ===" },
  {
    "name": "buildsettings.get_build_info",
    "description": "Retrieve current build configuration: build version, changelist, branch name, build date, compatible changelist, is licensee build, is promoted build. Reads from FBuildSettings and FApp::GetBuildVersion(). Returns all available build metadata.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "include_fields": {
          "type": "array",
          "items": { "type": "string", "enum": ["version", "changelist", "compatible_changelist", "branch", "build_date", "is_licensee", "is_promoted"] },
          "description": "Which build info fields to return. Omit for all."
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "buildsettings.check_build_compatibility",
    "description": "Check build version compatibility between current editor build and a target changelist or build version string. Compares compatible changelist, network version, and engine association. Useful for verifying plugin/project compatibility.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "target_changelist": { "type": "integer", "description": "Target changelist number to compare against" },
        "target_version": { "type": "string", "description": "Target build version string to compare against" }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  { "_comment": "=== BLUEPRINTRUNTIME  Runtime/BlueprintRuntime: Blueprint nativization and runtime support ===" },
  {
    "name": "blueprintruntime.get_runtime_stats",
    "description": "Query Blueprint runtime performance statistics: number of nativized Blueprints, interpreted vs nativized execution counts, VM instruction stats, Blueprint class memory usage, and compilation status. Uses FBlueprintRuntime instrumentation data.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "blueprint_path": { "type": "string", "description": "Optional: specific Blueprint asset path to query. Omit for aggregate stats." },
        "include_vm_stats": { "type": "boolean", "default": false, "description": "Include detailed VM instruction execution statistics" }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "blueprintruntime.list_nativized",
    "description": "List all nativized Blueprint classes in the current build. Shows original Blueprint path, generated C++ class name, nativization status, and any conversion warnings. Uses UBlueprintGeneratedClass metadata.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "filter": { "type": "string", "description": "Substring filter on Blueprint name or path" },
        "status_filter": { "type": "string", "enum": ["all", "nativized", "pending", "failed"], "default": "all" }
      },
      "additionalProperties": false,
      "required": []
    }
  },

  { "_comment": "=== BUILDPATCH  Runtime/BuildPatchServices: Chunk-based patching and content delivery ===" },
  {
    "name": "buildpatch.get_manifest_info",
    "description": "Read and parse a BuildPatchServices manifest file (.manifest). Returns app name, version string, launch executable, chunk list, file list with sizes/hashes, and prerequisite info. Uses FBuildPatchServicesModule manifest parsing.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "manifest_path": { "type": "string", "description": "Path to the .manifest file to parse" }
      },
      "additionalProperties": false,
      "required": ["manifest_path"]
    }
  },
  {
    "name": "buildpatch.check_patch_status",
    "description": "Query the current patching/download status: download progress percentage, bytes downloaded/remaining, current download speed, active chunk requests, installation verification state, and any errors. Uses IBuildInstaller interface.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "installation_id": { "type": "string", "description": "Optional installation ID to query. Omit for active installation." }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "buildpatch.list_chunks",
    "description": "List chunks in a build manifest with their GUIDs, sizes, hashes, and data groups. Supports filtering by data group or file association. Uses FChunkInfo from the manifest.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "manifest_path": { "type": "string", "description": "Path to the .manifest file" },
        "data_group": { "type": "string", "description": "Filter chunks by data group name" },
        "file_filter": { "type": "string", "description": "Show only chunks associated with files matching this substring" }
      },
      "additionalProperties": false,
      "required": ["manifest_path"]
    }
  },

  { "_comment": "=== APPFRAMEWORK  Runtime/AppFramework: Slate application framework, windows, and widget management ===" },
  {
    "name": "appframework.list_windows",
    "description": "List all active Slate windows (SWindow) in the application. Returns window title, size, position, type (normal/tooltip/notification/menu/cursor decorator), visibility, maximize/minimize state, and native window handle. Uses FSlateApplication::Get().GetInteractiveTopLevelWindows().",
    "inputSchema": {
      "type": "object",
      "properties": {
        "include_hidden": { "type": "boolean", "default": false, "description": "Include hidden/invisible windows" },
        "type_filter": { "type": "string", "enum": ["all", "normal", "tooltip", "notification", "menu"], "default": "all" }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "appframework.get_app_info",
    "description": "Query FSlateApplication state: active modal windows count, focused widget path, captured mouse widget, cursor position, platform application name, average delta time, is running, high-DPI scale factor, and virtual desktop bounds.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "include_fields": {
          "type": "array",
          "items": { "type": "string", "enum": ["focus", "cursor", "modals", "platform", "timing", "dpi", "desktop_bounds"] },
          "description": "Which fields to return. Omit for all."
        }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "appframework.manage_window",
    "description": "Manipulate a Slate window: bring to front, minimize, maximize, restore, resize, move, set title, set opacity, flash taskbar, or destroy. Identifies window by title substring or index from list_windows.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "window_title": { "type": "string", "description": "Title substring to match the target window" },
        "window_index": { "type": "integer", "description": "Window index from list_windows (0-based)" },
        "action": { "type": "string", "enum": ["bring_to_front", "minimize", "maximize", "restore", "resize", "move", "set_title", "set_opacity", "flash", "destroy"] },
        "position": { "type": "object", "properties": { "x": { "type": "integer" }, "y": { "type": "integer" } }, "description": "New position for 'move' action" },
        "size": { "type": "object", "properties": { "width": { "type": "integer" }, "height": { "type": "integer" } }, "description": "New size for 'resize' action" },
        "new_title": { "type": "string", "description": "New title for 'set_title' action" },
        "opacity": { "type": "number", "minimum": 0.0, "maximum": 1.0, "description": "Opacity for 'set_opacity' action" }
      },
      "additionalProperties": false,
      "required": ["action"]
    }
  },

  { "_comment": "=== ANIMATIONCORE  Runtime/AnimationCore: Low-level animation primitives, constraints, and bone structures ===" },
  {
    "name": "animationcore.list_constraints",
    "description": "List all animation constraints defined on a skeletal mesh or animation Blueprint. Returns constraint type (Aim, Parent, Position, Rotation, Scale), source/target bones, weight, maintain offset setting, and active state. Uses FConstraintDescription and FTransformConstraint.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "asset_path": { "type": "string", "description": "Skeletal mesh or anim Blueprint asset path" },
        "constraint_type_filter": { "type": "string", "enum": ["all", "aim", "parent", "position", "rotation", "scale"], "default": "all" }
      },
      "additionalProperties": false,
      "required": ["asset_path"]
    }
  },
  {
    "name": "animationcore.inspect_bone_chain",
    "description": "Inspect a bone chain or hierarchy in a skeleton. Returns each bone's index, name, parent index, reference pose transform (location/rotation/scale), and LOD settings. Uses FBoneReference and FReferenceSkeleton data.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skeleton_path": { "type": "string", "description": "Skeleton or SkeletalMesh asset path" },
        "root_bone": { "type": "string", "description": "Root bone name to start traversal from. Omit for full hierarchy." },
        "depth": { "type": "integer", "default": -1, "description": "Max traversal depth (-1 = unlimited)" },
        "include_transforms": { "type": "boolean", "default": true, "description": "Include reference pose transforms" }
      },
      "additionalProperties": false,
      "required": ["skeleton_path"]
    }
  },
  {
    "name": "animationcore.evaluate_transform",
    "description": "Evaluate transform operations using AnimationCore math utilities: apply axis mapping, convert between bone-space and component-space, compose constraint transforms, compute aim rotation toward target. Returns the resulting FTransform.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "operation": { "type": "string", "enum": ["bone_to_component", "component_to_bone", "apply_axis_map", "aim_at_target", "compose_constraints"] },
        "skeleton_path": { "type": "string", "description": "Skeleton asset for bone-space operations" },
        "bone_name": { "type": "string", "description": "Bone name for space conversion operations" },
        "input_transform": {
          "type": "object",
          "properties": {
            "location": { "type": "array", "items": { "type": "number" }, "minItems": 3, "maxItems": 3 },
            "rotation": { "type": "array", "items": { "type": "number" }, "minItems": 4, "maxItems": 4, "description": "Quaternion XYZW" },
            "scale": { "type": "array", "items": { "type": "number" }, "minItems": 3, "maxItems": 3 }
          }
        },
        "target_location": { "type": "array", "items": { "type": "number" }, "minItems": 3, "maxItems": 3, "description": "Target for aim_at_target" }
      },
      "additionalProperties": false,
      "required": ["operation"]
    }
  },

  { "_comment": "=== ANIMGRAPHRUNTIME  Runtime/AnimGraphRuntime: Anim graph nodes, blending, IK solvers, and pose drivers ===" },
  {
    "name": "animgraphruntime.list_anim_nodes",
    "description": "List available AnimGraph runtime node types: blend nodes (layered, per-bone, multi), IK solvers (CCDIK, FABRIK, TwoBone), pose drivers, look-at, spring controllers, trail controllers, slope warping, and custom nodes. Returns node class, category, input/output pin types.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "category_filter": { "type": "string", "enum": ["all", "blend", "ik", "pose_driver", "lookat", "physics", "modifier", "custom"], "default": "all" },
        "name_filter": { "type": "string", "description": "Substring filter on node class name" }
      },
      "additionalProperties": false,
      "required": []
    }
  },
  {
    "name": "animgraphruntime.inspect_node",
    "description": "Inspect an AnimGraph node instance in an Animation Blueprint: current blend weight, active state, input pose connections, property values (alpha, blend time, LOD threshold), and evaluation stats. Identifies node by class or graph position.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_bp_path": { "type": "string", "description": "Animation Blueprint asset path" },
        "node_class": { "type": "string", "description": "Node class name (e.g., FAnimNode_LayeredBoneBlend)" },
        "node_index": { "type": "integer", "description": "Node index in the anim graph" },
        "include_eval_stats": { "type": "boolean", "default": false, "description": "Include per-frame evaluation timing statistics" }
      },
      "additionalProperties": false,
      "required": ["anim_bp_path"]
    }
  },
  {
    "name": "animgraphruntime.configure_ik",
    "description": "Query or configure IK solver node settings in an AnimGraph: CCDIK (precision, max iterations, chain length), FABRIK (end effector, precision, max iterations), TwoBoneIK (effector/joint targets, twist axis), LookAt (look-at axis, clamp angle). Returns current settings or applies changes.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "anim_bp_path": { "type": "string", "description": "Animation Blueprint asset path" },
        "solver_type": { "type": "string", "enum": ["CCDIK", "FABRIK", "TwoBoneIK", "LookAt"] },
        "node_index": { "type": "integer", "description": "Node index if multiple solvers of same type exist" },
        "settings": {
          "type": "object",
          "properties": {
            "precision": { "type": "number" },
            "max_iterations": { "type": "integer" },
            "tip_bone": { "type": "string" },
            "root_bone": { "type": "string" },
            "effector_location": { "type": "array", "items": { "type": "number" }, "minItems": 3, "maxItems": 3 },
            "enable_debug_draw": { "type": "boolean" }
          },
          "description": "Settings to apply. Omit for read-only query."
        }
      },
      "additionalProperties": false,
      "required": ["anim_bp_path", "solver_type"]
    }
  }
]
